{"meta":{"title":"Anges Zhu","subtitle":null,"description":null,"author":"Anges Zhu","url":"https://angeszhu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-05-30T05:23:02.728Z","updated":"2019-05-29T07:06:20.000Z","comments":true,"path":"404/index.html","permalink":"https://angeszhu.github.io/404/index.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-05-30T05:23:02.746Z","updated":"2019-05-28T09:43:54.000Z","comments":true,"path":"about/index.html","permalink":"https://angeszhu.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-05-29T05:35:51.000Z","updated":"2019-05-29T07:03:02.000Z","comments":true,"path":"archives/index.html","permalink":"https://angeszhu.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-05-29T05:36:27.000Z","updated":"2019-05-29T05:39:55.000Z","comments":true,"path":"categories/index.html","permalink":"https://angeszhu.github.io/categories/index.html","excerpt":"","text":""},{"title":"行业大佬们","date":"2019-06-05T03:48:50.495Z","updated":"2019-06-05T03:48:50.495Z","comments":true,"path":"friends/index.html","permalink":"https://angeszhu.github.io/friends/index.html","excerpt":"","text":""},{"title":"开源项目","date":"2019-05-29T05:37:12.000Z","updated":"2019-05-29T06:41:05.000Z","comments":true,"path":"projects/index.html","permalink":"https://angeszhu.github.io/projects/index.html","excerpt":"","text":"Dubbo接口测试工具https://github.com/AngesZhu/mytool"},{"title":"所有标签","date":"2019-05-30T05:23:02.809Z","updated":"2019-05-28T09:48:10.000Z","comments":true,"path":"tags/index.html","permalink":"https://angeszhu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"django-admin和manage.py","slug":"django-admin","date":"2019-06-05T13:54:22.000Z","updated":"2019-06-05T14:10:40.682Z","comments":true,"path":"2019/06/05/django-admin/","link":"","permalink":"https://angeszhu.github.io/2019/06/05/django-admin/","excerpt":"","text":"django-admin和manage.py django-admin是Django用于管理任务的命令行实用程序。 manage.py在每个Django项目中自动创建。 django-admin但也设置了 DJANGO_SETTINGS_MODULE环境变量，以便它指向项目的settings.py文件。 通常，在处理单个Django项目时，它manage.py比django-admin使用起来更容易。如果您需要多个Django配置文件之间切换，使用django-admin与 DJANGO_SETTINGS_MODULE或–settings命令行选项。 本文档中的命令行示例django-admin用于保持一致，但任何示例都可以使用manage.py或 同样使用。python -m django 环境变量配置我们如果想要使用django-admin或者manage.py，那么则需要为它配置环境变量。 但是在安装时，通常都是自动配置的。 如果您不可以使用，那么请配置地址…/django/bin到环境变量中。 对于怎么配置环境变量，就不多坠述了。 使用示例123$ django-admin &lt;command&gt; [options]$ manage.py &lt;command&gt; [options]$ python -m django &lt;command&gt; [options] command是本文档中列出的命令之一。 options，是可选参数，应该是给定命令可用的零个或多个选项。 应用名称许多命令都会列出“应用名称”。 “app name”是包含模型的包的基本名称。 例如，如果您INSTALLED_APPS 包含字符串’mysite.blog’，则应用名称为blog。 版本 django-admin version运行以显示当前的Django版本。 1django-admin version 显示调试输出使用 –verbosity 指定的该通知和调试信息量django-admin打印到控制台。 可用命令 checkdjango-admin check [app_label [app_label …]] 使用系统检查框架检查整个Django项目是否存在常见问题。 默认情况下，将检查所有应用。您可以通过提供应用标签列表作为参数来检查应用的子集： 1django-admin check auth admin myapp 如果您未指定任何应用，则会检查所有应用。 –tag TAGS, -t TAGS 系统检查框架执行许多不同类型的检查，这些检查使用标记进行分类。 您可以使用这些标记将执行的检查限制为特定类别中的检查。例如，要仅执行模型和兼容性检查，请运行： 1django-admin check --tag models --tag compatibility –list-tags 列出所有可用标签。 –deploy 激活一些仅在部署设置中相关的其他检查。 您可以在本地开发环境中使用此选项，但由于您的本地开发设置模块可能没有很多生产设置，您可能希望将check命令指向不同的设置模块，可以通过设置DJANGO_SETTINGS_MODULE环境变量，也可以通过通过 –settings 选项： 1django-admin check --deploy --settings=production_settings 或者，您可以直接在生产或登台部署上运行它，以验证是否正在使用正确的设置（省略–settings）。您甚至可以将其作为集成测试套件的一部分。 1--fail-level &#123;CRITICAL,ERROR,WARNING,INFO,DEBUG&#125; 指定将导致命令以非零状态退出的消息级别。默认是ERROR。 compilemessages1django-admin compilemessages 编译.po通过创建的文件makemessages到.mo文件与内置的gettext支持使用。 见国际化和本地化。 –locale LOCALE, -l LOCALE 指定要处理的区域设置。如果未提供，则处理所有语言环境。 –exclude EXCLUDE, -x EXCLUDE 指定要从处理中排除的区域设置。如果未提供，则不排除任何语言环境。 –use-fuzzy, -f 包括模糊转换为编译文件。用法示例： 12345678django-admin compilemessages --locale=pt_BRdjango-admin compilemessages --locale=pt_BR --locale=fr -fdjango-admin compilemessages -l pt_BRdjango-admin compilemessages -l pt_BR -l fr --use-fuzzydjango-admin compilemessages --exclude=pt_BRdjango-admin compilemessages --exclude=pt_BR --exclude=frdjango-admin compilemessages -x pt_BRdjango-admin compilemessages -x pt_BR -x fr createcachetable1django-admin createcachetable 使用设置文件中的信息创建用于数据库缓存后端的缓存表。 –database DATABASE 指定将在其中创建缓存表的数据库。默认为 default。 –dry-run 打印将在不实际运行的情况下运行的SQL，以便您可以自定义它或使用迁移框架。 dbshell1django-admin dbshell 运行在您指定的数据库引擎的命令行客户端 ENGINE的设置，在您指定的连接参数USER，PASSWORD等等，设置。 对于PostgreSQL，它运行psql命令行客户端。 对于MySQL，它运行mysql命令行客户端。 对于SQLite，它运行sqlite3命令行客户端。 对于Oracle，这将运行sqlplus命令行客户端。 此命令假定程序对你的PATH，这样的程序名（一个简单的通话psql，mysql，sqlite3，sqlplus）会发现，在正确的地方节目。 无法手动指定程序的位置。 1--database DATABASE 指定要在其上打开shell的数据库。默认为default。 diffsettings1django-admin diffsettings 显示当前设置文件与Django默认设置（或指定的其他设置文件–default）之间的差异。 默认设置中未显示的设置后跟”###”。 例如，默认设置没有定义ROOT_URLCONF，因此 在输出中 ROOT_URLCONF后跟。“###”diffsettings –all 显示所有设置，即使它们具有Django的默认值。此类设置以前缀为前缀”###”。 –default MODULE 设置模块用于比较当前设置。留空以与Django的默认设置进行比较。 –output {hash,unified} 指定输出格式。可用值为hash和unified。 hash是显示上述输出的默认模式。 unified显示类似的输出。默认设置以减号为前缀，后跟带有加号前缀的更改设置。diff -u dumpdata1django-admin dumpdata [app_label[.ModelName] [app_label[.ModelName] ...]] 输出到标准输出与指定应用程序关联的数据库中的所有数据。 如果未提供应用程序名称，则将转储所有已安装的应用程序。 输出dumpdata可以用作输入loaddata。 请注意，dumpdata使用模型上的默认管理器来选择要转储的记录。 如果您使用自定义管理器作为默认管理器并且它过滤了一些可用记录，则不会转储所有对象。 –all, -a 使用Django的基本管理器，转储可能由自定义管理器过滤或修改的记录。 –format FORMAT 指定输出的序列化格式。默认为JSON。支持的格式以序列化格式列出。 –indent INDENT 指定要在输出中使用的缩进空格数。默认值 None显示单行上的所有数据。 –exclude EXCLUDE, -e EXCLUDE 防止app_label.ModelName转储特定应用程序或模型（以形式指定 ）。 如果指定模型名称，则输出将限制为该模型，而不是整个应用程序。 您还可以混合应用程序名称和型号名称。 如果要排除多个应用程序，请多次传递–exclude： 1django-admin dumpdata --exclude=auth --exclude=contenttypes –database DATABASE 指定将从中转储数据的数据库。 默认为default。 –natural-foreign 使用natural_key()模型方法序列化任何外键和与定义方法的类型的对象的多对多关系。 如果要转储contrib.auth Permission对象或contrib.contenttypes ContentType对象，则应该使用此标志。 –natural-primary 忽略此对象的序列化数据中的主键，因为它可以在反序列化期间计算。 –pks PRIMARY_KEYS 仅输出由逗号分隔的主键列表指定的对象。这仅在转储一个模型时可用。 默认情况下，输出模型的所有记录。 –output OUTPUT, -o OUTPUT 指定要将序列化数据写入的文件。默认情况下，数据转到标准输出。 设置此选项且–verbosity大于0（默认值）时，终端中将显示进度条。 flush1django-admin flush 从数据库中删除所有数据并重新执行任何后同步处理程序。 已清除已应用迁移的表。 如果您希望从空数据库开始并重新运行所有迁移，则应删除并重新创建数据库，然后再运行migrate。 –noinput, –no-input 禁止所有用户提示。 –database DATABASE 指定要刷新的数据库。默认为default。 inspectdb1django-admin inspectdb [table [table ...]] 反映NAME设置指向的数据库中的数据库表，并将 Django模型模块（models.py 文件）输出到标准输出。 您可以通过将其名称作为参数传递来选择要检查的表或视图。 如果未提供参数，则仅在使用该 –include-views 选项时才为视图创建模型。 如果使用该 –include-partitions 选项，则在PostgreSQL上创建分区表的模型。 如果您有一个遗留数据库，您可以使用它来使用Django。 该脚本将检查数据库并为其中的每个表创建一个模型。 正如您所料，创建的模型将具有表中每个字段的属性。 请注意，inspectdb其字段名称输出中有一些特殊情况： 如果inspectdb无法将列的类型映射到模型字段类型，它将使用TextField并将在生成的模型中的字段旁边插入Python注释 。 已识别的字段可能取决于中列出的应用 。 例如，添加了对几种PostgreSQL特定字段类型的识别。 ‘This field type is aguess.’INSTALLED_APPSdjango.contrib.postgres 如果数据库列名是Python保留字（例如 ‘pass’，’class’或’for’），inspectdb则会附加’_field’ 到属性名称。 例如，如果表具有列 ‘for’，则生成的模型将具有一个字段’for_field’，其db_column属性设置为’for’。inspectdb将在该字段旁边插入Python注释 。 ‘Field renamed because it was a Python reserved word.’ 此功能用作快捷方式，而不是确定的模型生成。 运行它之后，您将需要自己查看生成的模型以进行自定义。 特别是，您需要重新排列模型的顺序，以便正确排序引用其他模型的模型。 当default在模型字段上指定a 时，Django不会创建数据库默认值 。 同样，数据库默认值不会转换为模型字段默认值或以任何方式检测inspectdb。 默认情况下，inspectdb创建非托管模型。 也就是说， 在模型的类中告诉Django不要管理每个表的创建，修改和删除。 如果你想让Django管理表的生命周期，你需要将选项更改 为（或者只是删除它，因为它是默认值）。managed = FalseMetamanagedTrueTrue 特定于数据库的注释 Oracle 如果–include-views使用，则为物化视图创建模型。 PostgreSQL的 为外表创建模型。 如果–include-views使用，则为物化视图创建模型 。 如果–include-partitions使用，则为分区表创建模型 。 在Django 2.2中更改：增加了对外国表和物化视图的支持。 –database DATABASE 指定要内省的数据库。默认为default。 –include-partitions Django 2.2中的新功能： 如果提供此选项，还会为分区创建模型。仅实现了对PostgreSQL的支持。 –include-views Django 2.1中的新功能： 如果提供此选项，还会为数据库视图创建模型。 loaddata1django-admin loaddata fixture [fixture ...] 搜索并将指定fixture的内容加载到数据库中。 –database DATABASE 指定要将数据加载到的数据库。默认为 default。 –ignorenonexistent, -i 忽略自最初生成灯具后可能已删除的字段和模型。 –app APP_LABEL 指定单个应用程序以查找夹具而不是查看所有应用程序。 –format FORMAT 指定从stdin读取的装置的序列化格式（例如， json或xml）。 –exclude EXCLUDE, -e EXCLUDE 不包括从给定的应用程序和/或模型（以app_label或的形式app_label.ModelName）加载灯具。多次使用该选项可排除多个应用或型号。 什么是“夹具”？一个夹具是包含数据库的序列化内容的文件的集合。 每个夹具都有一个唯一的名称，构成夹具的文件可以分布在多个应用程序的多个目录中。 Django将在三个地点搜索固定装置： 在fixtures每个已安装的应用程序的目录中 在FIXTURE_DIRS设置中指定的任何目录中 在夹具命名的文字路径中 Django将加载它在这些位置匹配提供的灯具名称的任何和所有灯具。 如果命名夹具具有文件扩展名，则仅加载该类型的夹具。例如： 12django-admin loaddata mydata.json 只会加载调用的JSON装置mydata。夹具扩展必须对应于序列化器的注册名称 （例如，json或xml）。 如果省略扩展，Django将搜索所有可用的夹具类型以获得匹配的夹具。例如： 1django-admin loaddata mydata 会寻找任何夹具类型的任何夹具mydata。如果包含fixture目录mydata.json，该夹具将作为JSON fixture加载。 命名的灯具可以包含目录组件。这些目录将包含在搜索路径中。例如： 1django-admin loaddata foo/bar/mydata.json 将搜索/fixtures/foo/bar/mydata.json每个已安装的应用程序， /foo/bar/mydata.json每个目录FIXTURE_DIRS和文字路径foo/bar/mydata.json。 处理夹具文件时，数据将按原样保存到数据库中。save()不调用模型定义的方法，并且将调用任何pre_save或 post_save信号，raw=True因为实例仅包含模型本地的属性。例如，您可能希望禁用访问夹具加载期间不存在的相关字段的处理程序，否则会引发异常： 12345678from django.db.models.signals import post_savefrom .models import MyModeldef my_handler(**kwargs): # disable the handler during fixture loading if kwargs[&apos;raw&apos;]: return ...post_save.connect(my_handler, sender=MyModel) 您还可以编写一个简单的装饰器来封装此逻辑： 12345678910111213from functools import wrapsdef disable_for_loaddata(signal_handler): &quot;&quot;&quot; Decorator that turns off signal handlers when loading fixture data. &quot;&quot;&quot; @wraps(signal_handler) def wrapper(*args, **kwargs): if kwargs[&apos;raw&apos;]: return signal_handler(*args, **kwargs) return wrapper@disable_for_loaddatadef my_handler(**kwargs): ... 请注意，无论何时对灯具进行反序列化，此逻辑都会禁用信号loaddata。 请注意，处理夹具文件的顺序是未定义的。但是，所有夹具数据都作为单个事务安装，因此一个夹具中的数据可以引用另一个夹具中的数据。如果数据库后端支持行级约束，则将在事务结束时检查这些约束。 该dumpdata命令可用于生成输入loaddata。 压缩灯具夹具可以被压缩zip，gz或bz2格式。例如： 1django-admin loaddata mydata.json 会寻找任何的mydata.json，mydata.json.zip， mydata.json.gz，或mydata.json.bz2。 使用zip压缩存档中包含的第一个文件。 请注意，如果使用相同的名称但不同的灯具类型两场比赛被发现（例如，如果mydata.json和 mydata.xml.gz是在相同的固件目录中找到），灯具安装将被中止，并安装在调用任何数据 loaddata将被从数据库中删除。 MySQL与MyISAM和灯具MySQL的MyISAM存储引擎不支持事务或约束，因此如果使用MyISAM，您将无法获得夹具数据的验证，或者如果找到多个事务文件则回滚。 特定于数据库的灯具如果您处于多数据库设置中，则可能需要将夹具数据加载到一个数据库中，而不是加载到另一个数据库上。 在这种情况下，您可以将数据库标识符添加到灯具的名称中。 例如，如果您的DATABASES设置已定义“主”数据库，则命名夹具mydata.master.json或 mydata.master.json.gz仅在您指定要将数据加载到master数据库时才加载夹具。 从stdin加载灯具您可以使用短划线作为夹具名称来加载输入sys.stdin。例如： 1django-admin loaddata --format=json - 读取时stdin，–format需要选项指定 输入的序列化格式（例如，json或xml）。 加载from stdin对标准输入和输出重定向很有用。例如： 1django-admin dumpdata --format=json --database=test app_label.ModelName | django-admin loaddata --format=json --database=prod - makemessages1django-admin makemessages 遍历当前目录的整个源树，并拉出标记为要进行转换的所有字符串。 它在conf / locale（在Django树中）或locale（用于项目和应用程序）目录中创建（或更新）消息文件。 在对消息文件进行更改之后，您需要将它们编译compilemessages为与builtin gettext支持一起使用。 此命令不需要配置设置。 但是，如果未配置设置，则命令不能忽略MEDIA_ROOT和 STATIC_ROOT目录或包含LOCALE_PATHS。 –all, -a 更新所有可用语言的消息文件。 –extension EXTENSIONS, -e EXTENSIONS 指定要检查的文件扩展名列表（默认：html，txt， py或者js如果–domain是js）。用法示例： 1django-admin makemessages --locale=de --extension xhtml 用逗号分隔多个扩展名或使用-e或–extension 多次： 1django-admin makemessages --locale=de --extension=html,txt --extension xml –locale LOCALE, -l LOCALE 指定要处理的区域设置。 –exclude EXCLUDE, -x EXCLUDE 指定要从处理中排除的区域设置。如果未提供，则不排除任何语言环境。 用法示例： 12345678django-admin makemessages --locale=pt_BRdjango-admin makemessages --locale=pt_BR --locale=frdjango-admin makemessages -l pt_BRdjango-admin makemessages -l pt_BR -l frdjango-admin makemessages --exclude=pt_BRdjango-admin makemessages --exclude=pt_BR --exclude=frdjango-admin makemessages -x pt_BRdjango-admin makemessages -x pt_BR -x fr –domain DOMAIN, -d DOMAIN 指定消息文件的域。支持的选项是： django对于所有.py，.html和*.txt文件（默认） djangojs对于*.js文件 –symlinks, -s 在查找新的翻译字符串时，遵循符号链接到目录。用法示例： 12django-admin makemessages --locale=de --symlinks –ignore PATTERN, -i PATTERN 忽略与给定glob样式模式匹配的文件或目录。多次使用可忽略更多。 这些模式是默认使用：’CVS’，’.‘，’~’，’*.pyc’。用法示例： 1django-admin makemessages --locale=en_US --ignore=apps/* --ignore=secret/*.html –no-default-ignore 禁用默认值 –ignore。–no-wrap 禁用将长消息行分成语言文件中的多行。 –no-location 禁止在语言文件中写入’ ‘注释行。 使用此选项会使技术熟练的翻译人员更难理解每条消息的上下文。#: filename:line –add-location [{full,file,never}] 控制语言文件中的注释行。如果选项是：#: filename:line full （默认情况下，如果没有给出）：这些行包括文件名和行号。 file：行号被省略。 never：线被抑制（相同–no-location）。 需要gettext0.19或更新。 –keep-pot 防止删除.pot在创建.po文件之前生成的 临时文件。这对于调试可能阻止创建最终语言文件的错误很有用。 makemigrations1django-admin makemigrations [app_label [app_label ...]] 根据检测到的模型更改创建新的迁移。迁移文档中详细介绍了迁移，它们与应用程序的关系等 。 提供一个或多个应用程序名称作为参数将限制为指定的应用程序创建的迁移以及所需的任何依赖项（例如，在另一端的表ForeignKey）。 要将迁移添加到没有migrations目录makemigrations的应用程序，请使用该应用程序运行 app_label。 –noinput, –no-input 禁止所有用户提示。如果无法自动解决被抑制的提示，则该命令将以错误代码3退出。 –empty 输出指定应用程序的空迁移，以进行手动编辑。 这适用于高级用户，除非您熟悉迁移格式，迁移操作以及迁移之间的依赖关系，否则不应使用此用户。 –dry-run 显示在不将任何迁移文件实际写入磁盘的情况下进行的迁移。 使用此选项还将显示将要写入的完整迁移文件。 –verbosity 3–merge 可以修复迁移冲突。 –name NAME, -n NAME 允许命名生成的迁移，而不是使用生成的名称。该名称必须是有效的Python 标识符。 –no-header Django 2.2中的新功能： 生成没有Django版本和时间戳标头的迁移文件。 –check makemigrations当检测到没有迁移的模型更改时，使退出处于非零状态。 migrate1django-admin migrate [app_label] [migration_name] 使数据库状态与当前模型和迁移集同步。 迁移文档中详细介绍了迁移，它们与应用程序的关系等 。 此命令的行为根据提供的参数而更改： 没有参数：所有应用程序都运行了所有迁移。 ：指定的应用程序将运行其迁移，直至最近的迁移。这可能涉及由于依赖性而运行其他应用程序的迁移。 ：将数据库架构置于应用命名迁移的状态，但不应用同一应用程序中的后续迁移。如果您之前已迁移过指定的迁移，则可能涉及取消应用迁移。使用该名称zero取消应用应用的所有迁移。 –database DATABASE 指定要迁移的数据库。默认为default。 –fake 将迁移标记为应用的目标迁移（遵循上述规则），但不实际运行SQL以更改数据库模式。 这适用于高级用户在手动应用更改时直接操作当前迁移状态; 请注意，使用–fake运行会导致将迁移状态表置于需要手动恢复以使迁移正确运行的状态。 –fake-initial 如果所有具有该CreateModel迁移中所有操作创建的模型名称的数据库表已存在，则允许Django跳过应用程序的初始迁移 。 此选项适用于首次针对预先存在使用迁移的数据库运行迁移时使用。 但是，此选项不会检查匹配的表名称之外的匹配数据库模式，因此只有在您确信现有模式与初始迁移中记录的模式匹配时才可以安全使用。 –plan Django 2.2中的新功能： 显示将对给定migrate 命令执行的迁移操作。 –run-syncdb 允许在不迁移的情况下为应用创建表。 虽然不推荐这样做，但对于拥有数百个模型的大型项目，迁移框架有时会太慢。 –noinput, –no-input 禁止所有用户提示。示例提示是询问有关删除陈旧内容类型的问题。 runserver1django-admin runserver [addrport] 在本地计算机上启动轻量级开发Web服务器。 默认情况下，服务器在IP地址的端口8000上运行127.0.0.1。 您可以明确传入IP地址和端口号。 如果以具有普通权限的用户身份运行此脚本（推荐），则可能无权在低端口号上启动端口。 低端口号保留给超级用户（root）。 此服务器使用该WSGI_APPLICATION设置指定的WSGI应用程序对象 。 请勿在生产设置中使用此服务器。 它没有经过安全审核或性能测试。（这就是它将如何保留。我们的业务是制作Web框架，而不是Web服务器，因此改进此服务器以便能够处理生产环境超出了Django的范围。） 根据需要，开发服务器会自动为每个请求重新加载Python代码。 您无需重新启动服务器即可使代码更改生效。 但是，某些操作（如添加文件）不会触发重新启动，因此在这些情况下您必须重新启动服务器。 如果您正在使用Linux或MacOS并同时安装pywatchman和 Watchman服务，则内核信号将用于自动加载服务器（而不是每秒轮询文件修改时间戳）。 这为大型项目提供了更好的性能，减少了代码更改后的响应时间，更强大的变更检测以及降低了功耗。 包含许多文件的大型目录可能会导致性能问题当Watchman使用包含大型非Python目录的项目时，node_modules建议忽略此目录以获得最佳性能。有关如何执行此操作的信息，请参阅watchman文档。 watchman超时Watchman客户端的默认超时为5秒。您可以通过设置DJANGO_WATCHMAN_TIMEOUT环境变量来更改它。 在Django 2.2中更改：Watchman支持取代了对pyinotify的支持。 当您启动服务器时，每次在服务器运行时更改Python代码时，系统检查框架将检查整个Django项目是否存在一些常见错误。如果发现任何错误，它们将打印到标准输出。 您可以根据需要运行任意数量的并发服务器，只要它们位于不同的端口上即可。只需执行多次。django-admin runserver 请注意，127.0.0.1无法从网络上的其他计算机访问默认IP地址。要使您的开发服务器可以在网络上的其他计算机上查看，请使用其自己的IP地址（例如192.168.2.1）或 0.0.0.0或::（启用IPv6）。 您可以提供括号括起来的IPv6地址（例如[200a::1]:8000）。这将自动启用IPv6支持。 也可以使用包含仅ASCII字符的主机名。 如果启用了staticfiles contrib app（新项目中的默认值），runserver则将使用自己的runserver命令覆盖该命令。 记录每个请求和服务器的响应将发送到 django.server记录器。 –noreload 禁用自动重新加载器。这意味着如果特定的Python模块已经加载到内存中，那么在服务器运行时所做的任何Python代码更改都不会生效。 –nothreading 禁用在开发服务器中使用线程。默认情况下，服务器是多线程的。 –ipv6, -6 将IPv6用于开发服务器。这会将默认IP地址更改 127.0.0.1为::1。 使用不同端口和地址的示例IP地址上的端口8000 127.0.0.1： 1django-admin runserver IP地址上的端口8000 1.2.3.4： 1django-admin runserver 1.2.3.4:8000 IP地址上的端口7000 127.0.0.1： 1django-admin runserver 7000 IP地址上的端口7000 1.2.3.4： 1django-admin runserver 1.2.3.4:7000 IPv6地址上的端口8000 ::1： 1django-admin runserver -6 IPv6地址上的端口7000 ::1： 1django-admin runserver -6 7000 IPv6地址上的端口7000 2001:0db8:1234:5678::9： 1django-admin runserver [2001:0db8:1234:5678::9]:7000 主机IPv4地址上的端口8000 localhost： 1django-admin runserver localhost:8000 主机IPv6地址上的端口8000 localhost： 1django-admin runserver -6 localhost:8000 使用开发服务器提供静态文件默认情况下，开发服务器不为您的站点提供任何静态文件（例如CSS文件，图像，MEDIA_URL等等）。如果要配置Django以提供静态媒体，请阅读 管理静态文件（比如图片，JavaScript，CSS）。 sendtestemail1django-admin sendtestemail [email [email ...]] 向指定的收件人发送测试电子邮件（以确认通过Django发送的电子邮件正在发送）。例如： 1django-admin sendtestemail foo@example.com bar@example.com 有几个选项，您可以将它们的任意组合使用在一起： –managers 邮件中指定的电子邮件地址MANAGERS使用 mail_managers()。 –admins 邮件中指定的电子邮件地址ADMINS使用 mail_admins()。 shell1django-admin shell 启动Python交互式解释器。 1--interface &#123;ipython,bpython,python&#125;, -i &#123;ipython,bpython,python&#125; 指定要使用的shell。默认情况下，如果安装了任何一个，Django将使用IPython或bpython。如果两者都已安装，请指定您想要的那样：IPython的： 1django-admin shell -i ipython bpython： 1django-admin shell -i bpython 如果您安装了“丰富”shell，但想强制使用“普通”Python解释器，请使用python接口名称，如下所示： 1django-admin shell -i python –nostartup 禁用读取“普通”Python解释器的启动脚本。默认情况下，脚本指向的脚本PYTHONSTARTUP环境变量或~/.pythonrc.py脚本被读取。 –command COMMAND, -c COMMAND 允许您将命令作为字符串传递给Django执行它，如下所示： 1django-admin shell --command=&quot;import django; print(django.__version__)&quot; 您还可以在标准输入上传递代码以执行它。例如： 1234$ django-admin shell &lt;&lt;EOF&gt; import django&gt; print(django.__version__)&gt; EOF 在Windows上，由于select.select()该平台的实施限制，输出REPL 。 showmigrations1django-admin showmigrations [app_label [app_label ...]] 显示项目中的所有迁移。您可以选择以下两种格式之一： –list, -l 列出Django所知道的所有应用程序，每个应用程序可用的迁移，以及是否应用每个迁移（由[X]迁移名称旁边标记）。 还会列出没有迁移的应用，但会在其下方打印。(no migrations) 这是默认输出格式。 –plan, -p 显示Django将遵循的迁移计划以应用迁移。比如 –list，应用的迁移标记为[X]。对于–verbosity 2及以上的a，还将显示迁移的所有依赖关系。 app_labels参数限制输出，但是，也可以包括提供的应用程序的依赖性。 –database DATABASE 指定要检查的数据库。默认为default。 sqlflush1django-admin sqlflush 打印将为该flush 命令执行的SQL语句。 –database DATABASE 指定要为其打印SQL的数据库。默认为default。 sqlmigrate1django-admin sqlmigrate app_label migration_name 打印指定迁移的SQL。这需要一个活动的数据库连接，它将用于解析约束名称; 这意味着您必须针对您希望稍后应用它的数据库副本生成SQL。 请注意，sqlmigrate它不会使其输出着色。 –backwards 生成用于取消应用迁移的SQL。默认情况下，创建的SQL用于在向前方向上运行迁移。 –database DATABASE 指定要为其生成SQL的数据库。默认为default。 sqlsequencereset1django-admin sqlsequencereset app_label [app_label ...] 打印SQL语句以重置给定应用程序名称的序列。 序列是某些数据库引擎用于跟踪自动递增字段的下一个可用数字的索引。 使用此命令生成SQL，该SQL将修复序列与其自动递增的字段数据不同步的情况。 –database DATABASE 指定要为其打印SQL的数据库。默认为default。 squashmigrations1django-admin squashmigrations app_label [start_migration_name] migration_name 如果可能的话，将迁移压缩到最少app_label并包括migration_name更少的迁移。 由此产生的压扁迁移可以安全地与未取消的迁移一起生活。 当start_migration_name给定，Django将只包括从迁移开始，包括这个迁移。这有助于减轻压缩RunPython和django.db.migrations.operations.RunSQL迁移操作的压缩。 –no-optimize 生成压缩迁移时禁用优化程序。 默认情况下，Django将尝试优化迁移中的操作以减小生成的文件的大小。 如果此过程失败或创建不正确的迁移，请使用此选项，但请同时提交有关行为的Django错误报告，因为优化是安全的。 –noinput, –no-input 禁止所有用户提示。 –squashed-name SQUASHED_NAME 设置压缩迁移的名称。省略时，名称基于第一次和最后一次迁移，_squashed_介于两者之间。 –no-header Django 2.2中的新功能： 生成没有Django版本和时间戳标头的压缩迁移文件。 startapp1django-admin startapp name [directory] 为当前目录或给定目标中的给定应用程序名称创建Django应用程序目录结构。 默认情况下，新目录包含 models.py文件和其他应用程序模板文件。 如果仅给出应用程序名称，则将在当前工作目录中创建应用程序目录。 如果提供了可选目标，Django将使用该现有目录而不是创建新目录。 您可以使用 ‘。’ 表示当前的工作目录。例如： 1django-admin startapp myapp /Users/jezdez/Code/myapp –template TEMPLATE 提供了路径与自定义应用程序模板文件或路径，以一个压缩文件（目录.tar.gz，.tar.bz2，.tgz，.tbz，.zip）包含应用程序模板文件。 例如，这将在创建myapp应用程序时在给定目录中查找应用程序模板： 1django-admin startapp --template=/Users/jezdez/Code/my_app_template myapp Django的也将接受的URL（ ，http，https），ftp以与应用程序模板文件压缩档案，下载和上飞提取它们。 例如，利用GitHub的功能将存储库公开为zip文件，您可以使用以下URL： 1django-admin startapp --template=https://github.com/githubuser/django-app-template/archive/master.zip myapp –extension EXTENSIONS, -e EXTENSIONS 指定应使用模板引擎呈现应用程序模板中的哪些文件扩展名。默认为py。 –name FILES, -n FILES 指定–extension应使用模板引擎呈现应用程序模板中的哪些文件（以及匹配的文件 ）。默认为空列表。 将用于所有匹配的文件是：template context 传递给startapp命令的任何选项（在命令支持的选项中） app_name - 传递给命令的应用程序名称 app_directory - 新创建的应用程序的完整路径 camel_case_app_name - 驼峰案例格式的应用程序名称 docs_version- 文档的版本：’dev’或’1.x’ django_version - Django的版本，例如2.0.3 警告当使用Django模板引擎（默认情况下所有.py文件）呈现应用程序模板文件时，Django还将替换包含的所有杂散模板变量。例如，如果其中一个Python文件包含解释与模板呈现相关的特定功能的文档字符串，则可能会导致错误的示例。若要解决此问题，您可以使用templatetag 模板标记“转义”模板语法的各个部分。此外，为了允许包含Django模板语言语法的Python模板文件同时还防止打包系统尝试字节编译无效.py文件，.py-tpl 将以重命名的模板文件重命名为.py。 startproject1django-admin startproject name [directory] 为当前目录或给定目标中的给定项目名创建Django项目目录结构。 默认情况下，新目录包含 manage.py一个项目包（包含一个settings.py和其他文件）。 如果仅给出项目名称，则将命名项目目录和项目包，并在当前工作目录中创建项目目录。 如果提供了可选目标，Django将使用该现有目录作为项目目录，并在其中创建manage.py项目包。 使用 ‘。’ 表示当前的工作目录。例如： 1django-admin startproject myproject /Users/jezdez/Code/myproject_repo –template TEMPLATE 指定自定义项目模板的目录，文件路径或URL。startapp –template –extension EXTENSIONS, -e EXTENSIONS 指定应使用模板引擎呈现项目模板中的哪些文件扩展名。默认为py。 –name FILES, -n FILES 指定–extension应使用模板引擎呈现项目模板中的哪些文件（以及匹配的文件 ）。默认为空列表。 该采用的是：template context 传递给startproject命令的任何选项（在命令支持的选项中） project_name - 传递给命令的项目名称 project_directory - 新创建项目的完整路径 secret_key- SECRET_KEY设置的随机密钥 docs_version- 文档的版本：’dev’或’1.x’ django_version - Django的版本，例如2.0.3 test1django-admin test [test_label [test_label ...]] 运行所有已安装应用的测试。 –failfast 在测试失败后立即停止运行测试并报告失败。 –testrunner TESTRUNNER 控制用于执行测试的测试运行器类。此值将覆盖设置提供的值TEST_RUNNER。 –noinput, –no-input 禁止所有用户提示。典型的提示是关于删除现有测试数据库的警告。 Test runner options该test命令代表指定的接收选项 –testrunner。这些是默认测试运行器的选项： DiscoverRunner。 –keepdb, -k 在测试运行之间保留测试数据库。 这样做的优点是可以跳过create和destroy操作，这可以大大减少运行测试的时间，特别是在大型测试套件中。 如果测试数据库不存在，它将在第一次运行时创建，然后为每次后续运行保留。 在运行测试套件之前，任何未应用的迁移也将应用于测试数据库。 –reverse, -r 按相反的执行顺序对测试用例进行排序。这可能有助于调试未正确隔离的测试的副作用。 使用此选项时，将保留按测试类分组。 –debug-mode 将DEBUG设置设置True为运行测试之前。这可能有助于解决测试失败问题。 –debug-sql, -d 为失败的测试启用SQL日志记录。如果 –verbosity是2，则还输出传递测试中的查询。 –parallel [N] 在单独的并行进程中运行测试。 由于现代处理器具有多个内核，因此可以更快地运行测试。 默认情况下，–parallel每个核心运行一个进程 multiprocessing.cpu_count()。 您可以通过将其作为选项的值（例如–parallel=4，或通过设置DJANGO_TEST_PROCESSES环境变量）来调整进程数。 Django将测试用例 - unittest.TestCase子类 - 分发给子进程。 如果测试用例少于配置的进程，Django将相应地减少进程数。 每个进程都有自己的数据库。您必须确保不同的测试用例不访问相同的资源。 例如，触摸文件系统的测试用例应该创建一个供自己使用的临时目录。 此选项要求第三方tblib程序包正确显示回溯： 1$ pip install tblib Windows上不提供此功能。它也不适用于Oracle数据库后端。 如果要pdb在调试测试时使用，则必须禁用并行执行（–parallel=1）。bdb.BdbQuit如果不这样，你会看到类似的东西。 警告当启用测试并行化并且测试失败时，Django可能无法显示异常回溯。这可能使调试变得困难。如果遇到此问题，请在不进行并行化的情况下运行受影响的测试，以查看故障的回溯。这是一个已知的限制。它源于需要序列化对象以便在进程之间交换它们。 –tag TAGS 仅运行标有指定标签的测试。可以多次指定并结合使用。test –exclude-tag–exclude-tag EXCLUDE_TAGS 排除标有指定标签的测试。可以多次指定并结合使用。test –tag testserver1django-admin testserver [fixture [fixture ...]] runserver使用来自给定fixture的数据运行Django开发服务器（如）。 例如，这个命令： 1django-admin testserver mydata.json …将执行以下步骤： 1.创建一个测试数据库，如在测试数据库。 2.使用来自给定灯具的灯具数据填充测试数据库。 3.运行Django开发服务器（如runserver），指向这个新创建的测试数据库而不是生产数据库。 这在很多方面都很有用： 在编写视图如何使用某些夹具数据进行单元测试时，您可以testserver手动使用Web浏览器中的视图进行交互。 假设您正在开发Django应用程序并拥有一个您希望与之交互的数据库的“原始”副本。您可以将数据库转储到fixture（使用dumpdata上面解释的命令），然后使用testserver该数据运行Web应用程序。通过这种安排，您可以灵活地以任何方式搞乱数据，因为您知道您所做的任何数据更改都只是针对测试数据库。 请注意，此服务器也不会自动检测对你的Python代码（如runserver不）。但是，它会检测模板的更改。 –addrport ADDRPORT 指定默认值为的其他端口或IP地址和端口 127.0.0.1:8000。此值遵循完全相同的格式，并且与runserver命令的参数具有完全相同的功能。 例子： 使用fixture1和在端口7000上运行测试服务器fixture2： 12django-admin testserver --addrport 7000 fixture1 fixture2django-admin testserver fixture1 fixture2 --addrport 7000 （上面的陈述是等价的。我们将它们都包含在内，以证明选项是在夹具参数之前还是之后无关紧要。） 使用test夹具在1.2.3.4:7000上运行： 1django-admin testserver --addrport 1.2.3.4:7000 test –noinput, –no-input 禁止所有用户提示。典型的提示是关于删除现有测试数据库的警告。 应用程序提供的命令某些命令仅在实现它们 的django.contrib应用程序 可用时才可用。本节按其应用程序对它们进行分组。enabled django.contrib.authchangepassword1django-admin changepassword [&lt;username&gt;] 此命令仅在安装了Django的身份验证系统（django.contrib.auth）时可用。 允许更改用户密码。它会提示您为给定用户输入两次新密码。如果条目相同，则立即成为新密码。如果您未提供用户，该命令将尝试更改其用户名与当前用户匹配的密码。 –database DATABASE 指定要查询用户的数据库。默认为default。 用法示例： 1django-admin changepassword ringo createsuperuser1django-admin createsuperuser 此命令仅在安装了Django的身份验证系统（django.contrib.auth）时可用。 创建超级用户帐户（具有所有权限的用户）。如果您需要创建初始超级用户帐户，或者需要以编程方式为站点生成超级用户帐户，这将非常有用。 以交互方式运行时，此命令将提示输入新超级用户帐户的密码。以非交互方式运行时，不会设置密码，并且在为其手动设置密码之前，超级用户帐户将无法登录。 –username USERNAME –email EMAIL 可以使用命令行上的–username和–email参数提供新帐户的用户名和电子邮件地址。如果未提供其中任何一个，createsuperuser则在交互式运行时将提示它。 –database DATABASE 指定将保存超级用户对象的数据库。 get_input_data()如果要自定义数据输入和验证，则可以对管理命令进行子类化并覆盖。 例如，如果您有一个ForeignKeyin REQUIRED_FIELDS并希望允许创建实例而不是输入现有实例的主键，那么它可能很有用。 django.contrib.contenttypesremove_stale_contenttypes1django-admin remove_stale_contenttypes 此命令仅在安装了Django的contenttypes app（django.contrib.contenttypes）时可用。 删除数据库中的陈旧内容类型（来自已删除的模型）。依赖于已删除内容类型的任何对象也将被删除。在确认可以继续删除之前，将显示已删除对象的列表。 –database DATABASE 指定要使用的数据库。默认为default。 django.contrib.gisogrinspect此命令仅在安装GeoDjango （django.contrib.gis）时可用。 请参阅descriptionGeoDjango文档中的内容。 django.contrib.sessionsclearsessions1django-admin clearsessions 可以作为cron作业运行，也可以直接清除过期的会话。 django.contrib.sitemapsping_google此命令仅在安装Sitemaps framework（django.contrib.sitemaps）时可用。 1django-admin ping_google [sitemap_url] 将站点地图应用程序添加到项目后，您还可以使用ping_google管理命令ping Google ： 1python manage.py ping_google [/sitemap.xml] –sitemap-uses-http Django 2.2中的新功能： 如果您的站点地图使用http而不是，请使用此选项https。 django.contrib.staticfilescollectstatic仅当安装了静态文件application（django.contrib.staticfiles）时，此命令才可用。 1django-admin collectstatic 将静态文件收集到STATIC_ROOT。 默认情况下，重复文件名的解析方式与模板解析的工作方式类似：将首先使用在其中一个指定位置找到的文件。如果您感到困惑，该findstatic命令可以帮助您显示找到的文件。 在后续collectstatic运行（如果STATIC_ROOT不为空）时，仅当文件的修改时间戳大于文件的时间戳时才复制文件STATIC_ROOT。因此，如果从中删除应用程序 INSTALLED_APPS，最好使用该选项以删除过时的静态文件。collectstatic –clear 使用。搜索文件。默认值是中定义的所有地点寻找 ，并在由指定的应用程序的目录设置。enabled findersSTATICFILES_DIRS’static’INSTALLED_APPS 的collectstatic管理命令调用 post_process() 的方法STATICFILES_STORAGE每次运行后，并传递的已发现由管理命令的路径列表。它还接收所有命令行选项collectstatic。ManifestStaticFilesStorage 默认情况下使用此选项。 默认情况下，收集的文件从中接收权限，FILE_UPLOAD_PERMISSIONS并从中 收集目录FILE_UPLOAD_DIRECTORY_PERMISSIONS。如果您希望对这些文件和/或目录具有不同的权限，则可以将其中一个静态文件存储类子 类化，并分别指定 file_permissions_mode和/或directory_permissions_mode参数。例如： 1234567from django.contrib.staticfiles import storageclass MyStaticFilesStorage(storage.StaticFilesStorage): def __init__(self, *args, **kwargs): kwargs[&apos;file_permissions_mode&apos;] = 0o640 kwargs[&apos;directory_permissions_mode&apos;] = 0o760 super().__init__(*args, **kwargs) 然后将STATICFILES_STORAGE设置设置为 ‘path.to.MyStaticFilesStorage’。 一些常用的选项是： –noinput, –no-input 不要提示用户输入任何类型。 –ignore PATTERN, -i PATTERN 忽略与此glob样式模式匹配的文件，目录或路径。多次使用可忽略更多。指定路径时，始终使用正斜杠，即使在Windows上也是如此。 在Django 2.2中更改：路径匹配已添加。 –dry-run, -n 做一切，除了修改文件系统。 –clear, -c 在尝试复制或链接原始文件之前清除现有文件。 –link, -l 创建指向每个文件的符号链接，而不是复制。 –no-post-process 不要调用已post_process() 配置的STATICFILES_STORAGE存储后端的 方法。 –no-default-ignore 不要忽略常见的私有glob样式模式’CVS’，’.‘ 以及’~’。 有关选项的完整列表，请通过运行来参考命令自己的帮助： 1$ python manage.py collectstatic --help 自定义被忽略的模式列表默认忽略模式列表可以以比在每次调用时提供命令选项 更持久的方式进行自定义。提供自定义 类，覆盖此类的属性并替换 为您设置中的该类路径 ：[‘CVS’, ‘.‘, ‘~’]–ignorecollectstaticAppConfigignore_patterns’django.contrib.staticfiles’INSTALLED_APPS 1234from django.contrib.staticfiles.apps import StaticFilesConfigclass MyStaticFilesConfig(StaticFilesConfig): ignore_patterns = [...] # your custom ignore list findstatic仅当安装了静态文件application（django.contrib.staticfiles）时，此命令才可用。 1django-admin findstatic staticfile [staticfile ...] 使用启用的查找程序搜索一个或多个相对路径。 例如： 123456$ python manage.py findstatic css/base.css admin/js/core.jsFound &apos;css/base.css&apos; here: /home/special.polls.com/core/static/css/base.css /home/polls.com/core/static/css/base.cssFound &apos;admin/js/core.js&apos; here: /home/polls.com/src/django/contrib/admin/media/js/core.js findstatic –first 默认情况下，找到所有匹配的位置。要仅返回每个相对路径的第一个匹配项，请使用以下–first选项： 123$ python manage.py findstatic css/base.css --firstFound &apos;css/base.css&apos; here: /home/special.polls.com/core/static/css/base.css 这是一个调试辅助工具; 它会向您显示将为给定路径收集哪个静态文件。 通过将–verbosity标志设置为0，您可以抑制额外输出并获取路径名称： 123$ python manage.py findstatic css/base.css --verbosity 0/home/special.polls.com/core/static/css/base.css/home/polls.com/core/static/css/base.css 另一方面，通过将–verbosity标志设置为2，您可以获取所有搜索到的目录： 12345678$ python manage.py findstatic css/base.css --verbosity 2Found &apos;css/base.css&apos; here: /home/special.polls.com/core/static/css/base.css /home/polls.com/core/static/css/base.cssLooking in the following locations: /home/special.polls.com/core/static /home/polls.com/core/static /some/other/path/static 默认选项虽然某些命令可能允许自己的自定义选项，但每个命令都允许以下选项： –pythonpath PYTHONPATH 将给定的文件系统路径添加到Python 导入搜索路径。如果未提供，django-admin则使用PYTHONPATH环境变量。此选项是不必要的manage.py，因为它负责为您设置Python路径。 用法示例： 1django-admin migrate --pythonpath=&apos;/home/djangoprojects/myproject&apos; –settings SETTINGS 指定要使用的设置模块。设置模块应该是Python包语法，例如mysite.settings。如果未提供， django-admin则使用DJANGO_SETTINGS_MODULE环境变量。 此选项是不必要的manage.py，因为它settings.py默认使用当前项目。 用法示例： 1django-admin migrate --settings=mysite.settings –traceback CommandError 引发a时显示完整的堆栈跟踪。默认情况下，django-admin将在CommandError发生时显示简单的错误消息，并在任何其他异常时显示 完整的堆栈跟踪。 用法示例： 1django-admin migrate --traceback –verbosity {0,1,2,3}, -v {0,1,2,3} 指定命令应打印到控制台的通知和调试信息量。 0 意味着没有输出。 1 表示正常输出（默认）。 2 表示详细输出。 3意味着非常详细的输出。 用法示例： 1django-admin migrate --verbosity 2 –no-color 禁用彩色命令输出。某些命令将其输出格式化为彩色。例如，错误将以红色打印到控制台，SQL语句将突出显示语法。 用法示例： 1django-admin runserver --no-color –force-color Django 2.2中的新功能： 如果它将被禁用，则强制命令输出的颜色化，如语法着色中所述。例如，您可能希望将彩色输出管道传输到另一个命令。 额外的细节语法着色如果终端支持ANSI色输出，django-admin/ manage.pycommands将使用漂亮的颜色编码输出。如果您将命令的输出传递给另一个程序，除非使用该–force-color选项，否则它不会使用颜色代码。 在Windows下，本机控制台不支持ANSI转义序列，因此默认情况下没有颜色输出。但是你可以安装ANSICON 第三方工具，Django命令会检测它的存在，并将像在基于Unix的平台上一样利用其服务来进行颜色输出。 用于语法突出显示的颜色可以自定义。Django配有三种调色板： dark，适合在黑色背景上显示白色文本的终端。这是默认调色板。 light，适合在白色背景上显示黑色文本的终端。 nocolor，禁用语法高亮显示。 您可以通过设置DJANGO_COLORS环境变量来指定要使用的调色板来选择调色板。例如，要light在Unix或OS / X BASH shell下指定调色板，可以在命令提示符下运行以下命令： 1export DJANGO_COLORS=&quot;light&quot; 您还可以自定义使用的颜色。Django指定了许多使用颜色的角色： error - 一个重大错误。 notice - 一个小错误。 success - 成功。 warning - 一个警告。 sql_field - SQL中模型字段的名称。 sql_coltype - SQL中模型字段的类型。 sql_keyword - SQL关键字。 sql_table - SQL中模型的名称。 http_info - 1XX HTTP信息服务器响应。 http_success - 2XX HTTP Success服务器响应。 http_not_modified - 304 HTTP未修改的服务器响应。 http_redirect - 304以外的3XX HTTP重定向服务器响应。 http_not_found - 404 HTTP未找到服务器响应。 http_bad_request - 除404之外的4XX HTTP错误请求服务器响应。 http_server_error - 5XX HTTP服务器错误响应。 migrate_heading - 迁移管理命令中的标题。 migrate_label - 迁移名称。 可以从以下列表中为每个角色分配特定的前景色和背景色： black red green yellow blue magenta cyan white 然后可以使用以下显示选项修改这些颜色中的每一种： bold underscore blink reverse conceal 颜色规范遵循以下模式之一： role=fg role=fg/bg role=fg,option,option role=fg/bg,option,option 其中role是有效颜色角色的名称，fg是前景颜色，bg是背景颜色，每个颜色option 都是颜色修改选项之一。然后用分号分隔多种颜色规格。例如： 1export DJANGO_COLORS=&quot;error=yellow/blue,blink;notice=magenta&quot; 将指定使用蓝色闪烁黄色显示错误，并使用洋红色显示通知。所有其他颜色角色将保持未着色。 也可以通过扩展基础调色板来指定颜色。如果将调色板名称放在颜色规范中，则将加载该调色板隐含的所有颜色。所以： 1export DJANGO_COLORS=&quot;light;error=yellow/blue,blink;notice=magenta&quot; 将指定使用浅色调色板中的所有颜色， 但错误和通知的颜色除外，这些颜色将按指定覆盖。 Bash完成如果您使用Bash shell，请考虑安装Django bash完成脚本，该脚本extras/django_bash_completion位于Django源代码发行版中。它启用tab-completion django-admin和 manage.py命令，所以你可以，例如…… 类型django-admin。 按[TAB]查看所有可用选项。 键入sql，然后按[TAB]，查看名称以其开头的所有可用选项sql。 从代码运行管理命令1django.core.management.call_command（name，* args，** options） 从代码使用中调用管理命令call_command。 name 要调用的命令的名称或命令对象。除非测试需要该对象，否则优先传递名称。 *args 命令接受的参数列表。参数传递给参数解析器，因此您可以使用与命令行相同的样式。例如，。call_command(‘flush’, ‘–verbosity=0’) **options 命令行上接受的命名选项。选项传递给命令而不触发参数解析器，这意味着您需要传递正确的类型。例如，（零必须是整数而不是字符串）。call_command(‘flush’, verbosity=0) 例子： 123456from django.core import managementfrom django.core.management.commands import loaddatamanagement.call_command(&apos;flush&apos;, verbosity=0, interactive=False)management.call_command(&apos;loaddata&apos;, &apos;test_data&apos;, verbosity=0)management.call_command(loaddata.Command(), &apos;test_data&apos;, verbosity=0) 请注意，不带参数的命令选项将作为带有True或的关键字传递False，如interactive上面的选项所示。 可以使用以下语法之一传递命名参数： 123456789# Similar to the command linemanagement.call_command(&apos;dumpdata&apos;, &apos;--natural-foreign&apos;)# Named argument similar to the command line minus the initial dashes and# with internal dashes replaced by underscoresmanagement.call_command(&apos;dumpdata&apos;, natural_foreign=True)# `use_natural_foreign_keys` is the option destination variablemanagement.call_command(&apos;dumpdata&apos;, use_natural_foreign_keys=True) 使用call_command()而不是django-admin或时，某些命令选项具有不同的名称manage.py。例如，转换为。要查找要用于的关键字参数名称 ，请检查传递给的参数的命令源代码。 django-admin createsuperuser –no-inputcall_command(‘createsuperuser’, interactive=False)call_command()destparser.add_argument() 采用多个选项的命令选项将传递给列表： 1management.call_command(&apos;dumpdata&apos;, exclude=[&apos;contenttypes&apos;, &apos;auth&apos;]) 所述的返回值call_command()的功能是一样的的返回值handle()的命令的方法。 输出重定向请注意，您可以重定向标准输出和错误流，因为所有命令都支持stdout和stderr选项。 例如，你可以写： 12with open(&apos;/path/to/command_output&apos;, &apos;w&apos;) as f: management.call_command(&apos;dumpdata&apos;, stdout=f)","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Django","slug":"技术栈/Django","permalink":"https://angeszhu.github.io/categories/技术栈/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://angeszhu.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://angeszhu.github.io/tags/Web框架/"},{"name":"测试开发","slug":"测试开发","permalink":"https://angeszhu.github.io/tags/测试开发/"}]},{"title":"正则表达式","slug":"regular-base","date":"2019-06-03T13:53:45.000Z","updated":"2019-06-03T14:41:12.785Z","comments":true,"path":"2019/06/03/regular-base/","link":"","permalink":"https://angeszhu.github.io/2019/06/03/regular-base/","excerpt":"","text":"正则表达式什么是正则表达式? 正则表达式，又称规则表达式。(英语:Regular Expression，在代码中常简写为regex、regexp或RE)， 计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串(包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为“元字符”))操作的 一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这 个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要 匹配的一个或多个字符串。 使用目的给定一个正则表达式和另一个字符串，我们可以达到如下的目的: 给定的字符串是否符合正则表达式的过滤逻辑(称作“匹配”): 可以通过正则表达式，从字符串中获取我们想要的特定部分。 特点正则表达式的特点是: 灵活性、逻辑性和功能性非常强; 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus， 大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。 符号正则表达式由一些普通字符和一些元字符(metacharacters)组成。普通字符包括大小写的字母和数字，而 元字符则具有特殊的含义，我们下面会给予解释。 在最简单的情况下，一个正则表达式看上去就是一个普通的查找串。例如，正则表达式”testing”中没有包含 任何元字符，它可以匹配”testing”和”testing123”等字符串，但是不能匹配”Testing”。 要想真正的用好正则表达式，正确的理解元字符是最重要的事情。下表列出了所有的元字符和对它们的一个简短的描述。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列: 字 符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则 表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符所谓特殊字符，就是一些有特殊含义的字符，如 runoob 中的 ，简单的说就是表示任何字符串 的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 *: runoob* runoob。 许多元字符要求在试图匹配它们时特别对待。 若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜 杠字符** 放在它们前面。 下表列出了正则表达式中的特殊字符: 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或{n,m} 共6种。 正则表达式的限定符有: 字 符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等 价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪 或最小匹配。 例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下: 1&lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt; 贪婪:下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。 1/&lt;.*&gt;/ 非贪婪:如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 。 1/&lt;.*?&gt;/ 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式 出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有: 字 符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之 后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之 前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意:不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置， 因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式 内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。 但用圆括号会有一个副作用，使相关的匹配会 被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查， 在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中， 所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。 缓冲区编号从 1 开始，最多可存储 99 个捕获 的子表达式。 每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 符号完整列表 字 符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制 转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘&#39; 匹配 “” 而 “(“ 则匹配 “ (“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹 配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不 能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪 婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹 配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所 有 ‘o’。 . 匹配除换行符(\\n、\\r)之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使 用像”(. (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字 符，请使用 ‘(‘ 或 ‘)’。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使 用。这在使用 “或” 字符 ( (? =pattern) 正向肯定预查(look ahead positive assert)，在任何匹配pattern的字符串开始处匹配 查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例 如，”Windows(?=95 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符 串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例 如”Windows(?!95 (? &lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95 (? &lt;!pattern) 反向预定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95 `x y` [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中 的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小 写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A- Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例 如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编 码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连 续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引 用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制 转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配 版权符号 (?)。 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。 下表从最高到最低说明了各种正则表达式运算符的优先级顺序: 运算符 描述 \\ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列(即:位置和顺序) 常用实例定位点和序列(即:位置和顺序) 正则表达式 描述 /\\b([a-z]+) \\1\\b/gi 一个单词连续出现的位置。 /(\\w+)://([^/:]+)(:\\d)? ([^# ])/ 将一个URL解析为协议、域、端口及相对路径。 /^(?:Chapter Section) [1-9][0-9]{0,1}$/ /[-a-z]/ a至z共26个字母再加一个-号。 /ter\\b/ 可匹配chapter，而不能匹配terminal。 /\\Bapt/ 可匹配chapter，而不能匹配aptitude。 /Windows(?=95 98 /^\\s*$/ 匹配空行。 /\\d{2}-\\d{5}/ 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。 /&lt;\\s(\\S+)(\\s[^&gt;])?&gt;[\\s\\S] &lt;\\s/\\1\\s*&gt;/ 匹配 HTML 标记。 1.验证用户名和密码:(“^[a-zA-Z]\\w{5,15}$”)正确格式:”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母 6~16位; 2.验证电话号码:(“^(\\d{3,4}-)\\d{7,8}$”)正确格式:xxx/xxxx-xxxxxxx/xxxxxxxx; 3.验证手机号码:”^1[3|4|5|7|8][0-9]{9}$”; 4.验证身份证号(15位):”\\d{14}[[0-9],0-9xX]”，(18位):”\\d{17}(\\d|X|x)”; 5.验证Email地址:(“^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$”); 6.只能输入由数字和26个英文字母组成的字符串:(“^[A-Za-z0-9]+$”); 7.整数或者小数:^[0-9]+([.][0-9]+){0,1}$ 8.只能输入数字:”^[0-9]*$”。 9.只能输入n位的数字:”^\\d{n}$”。 10.只能输入至少n位的数字:”^\\d{n,}$”。 11.只能输入m~n位的数字:”^\\d{m,n}$”。 12.只能输入零和非零开头的数字:”^(0|[1-9][0-9]*)$”。 13.只能输入有两位小数的正实数:”^[0-9]+(.[0-9]{2})?$”。 14.只能输入有1~3位小数的正实数:”^[0-9]+(.[0-9]{1,3})?$”。 15.只能输入非零的正整数:”^+?[1-9][0-9]*$”。 16.只能输入非零的负整数:”^-[1-9][0-9]*$”。 17.只能输入长度为3的字符:”^.{3}$”。 18.只能输入由26个英文字母组成的字符串:”^[A-Za-z]+$”。 19.只能输入由26个大写英文字母组成的字符串:”^[A-Z]+$”。 20.只能输入由26个小写英文字母组成的字符串:”^[a-z]+$”。 21.验证是否含有^%&amp;’,;=?$”等字符:”[%&amp;’,;=?$^]+”。 22.只能输入汉字:”^[\\u4e00-\\u9fa5]{0,}$”。 23.验证URL:”^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$”。 24.验证一年的12个月:”^(0?[1-9]|1[0-2])$”正确格式为:”01”“09”和”10”“12”。 25.验证一个月的31天:”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式 为;”01”“09”、”10”“29”和“30”~“31”。 26.获取日期正则表达式:\\d{4}[年|-|.]\\d{\\1-\\12}[月|-|.]\\d{\\1-\\31}日? 评注:可用来匹配大多数年月日信息。 27.匹配双字节字符(包括汉字在内):[^\\x00-\\xff] 评注:可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1) 28.匹配空白行的正则表达式:\\n\\s*\\r 评注:可以用来删除空白行 29.匹配HTML标记的正则表达式:&lt;(\\S?)[^&gt;]&gt;.?&lt;/&gt;|&lt;.? /&gt; 评注:网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 30.匹配首尾空白字符的正则表达式:^\\s|\\s$ 评注:可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 31.匹配网址URL的正则表达式:[a-zA-z]+://[^\\s]* 评注:网上流传的版本功能很有限，上面这个基本可以满足需求 32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线):^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注:表单验证时很实用 33.匹配腾讯QQ号:[1-9][0-9]{4,} 评注:腾讯QQ号从10 000 开始 34.匹配中国邮政编码:[1-9]\\d{5}(?!\\d) 评注:中国邮政编码为6位数字 35.匹配ip地址:([1-9]{1,3}.){3}[1-9]。 评注:提取ip地址时有用","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"正则表达式","slug":"技术栈/正则表达式","permalink":"https://angeszhu.github.io/categories/技术栈/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://angeszhu.github.io/tags/正则表达式/"}]},{"title":"路由（Urls）","slug":"django-urls","date":"2019-06-03T13:47:10.000Z","updated":"2019-06-03T13:51:57.017Z","comments":true,"path":"2019/06/03/django-urls/","link":"","permalink":"https://angeszhu.github.io/2019/06/03/django-urls/","excerpt":"","text":"路由（URLS）什么是URL？ ​ URL（Uniform Resource Locator，统一资源定位符）是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，用于指出文件的路径位置。也就可以理解为，URL就是常说的网址，每一个地址代表了不同的网页，在Django中，URL也成为URLconf。 初始项目的urls 这是一个纯净项目的url配置文件，他存在的目录，是与setting文件在同一个目录中。 urlpatterns，就是一个保存url配置的变量，他的类型是list。 创建项目之后，这个文件中有一些例子了。 但是他在注释中也给了我们一些其他的用法。 第一种，就是他例子中的直接相对地址加上视图函数的名称。 第二种，则是导入urls文件，这样也给了我们其他更方便的配置方法，不必把所有的内容写到一个文件下。 我们可以通过include的方式把在其他位置写好的url配置文件导入进去。 同时，路径的匹配，还支持正则表达式。 12345678910# 导入Admin功能模块from django.contrib import admin# 导入URL编写模块from django.urls import path# urlpatterns 整个项目的url集合，每一个元素代表一条url信息urlpatterns = [ # 设定admin的url path(&apos;admin/&apos;, admin.site.urls),] ‘admin/‘ 代表的是127.0.0.1:8000/admin的地址，后面的斜杠是路径分隔符。 admin.site.urls是url的处理函数，即视图函数 URLconfs中的方法1.path()path(*route*, view**,** kwargs=None**,** name=None**)** 返回包含在中的元素urlpatterns 12345678910from django.urls import include, pathurlpatterns = [ path(&apos;index/&apos;, views.index, name=&apos;main-view&apos;), path(&apos;bio/&lt;username&gt;/&apos;, views.bio, name=&apos;bio&apos;), path(&apos;articles/&lt;slug:title&gt;/&apos;, views.article, name=&apos;article-detail&apos;), path(&apos;articles/&lt;slug:title&gt;/&lt;int:section&gt;/&apos;, views.section, name=&apos;article-section&apos;), path(&apos;weblog/&apos;, include(&apos;blog.urls&apos;)), ...] route参数应该是一个字符串或 gettext_lazy()，其中包含一个URL模式。该字符串可能包含尖括号（&lt;username&gt;如上所示）以捕获URL的一部分并将其作为关键字参数发送到视图。尖括号可以包括转换器规范（如int部分&lt;int:section&gt;），其限制匹配的字符并且还可以改变传递给视图的变量的类型。例如，&lt;int:section&gt;匹配一串十进制数字并将值转换为a int。 view参数是一个视图函数或的结果 as_view()为基于类的视图。它也可以是一个django.urls.include()。 该kwargs参数允许您将其他参数传递给视图函数或方法。 有关 name参数的内容，见url命名空间。 2.re_path()re_path(*route*, view**,** kwargs=None**,** name=None**)** 12345678from django.urls import include, re_pathurlpatterns = [ re_path(r&apos;^index/$&apos;, views.index, name=&apos;index&apos;), re_path(r&apos;^bio/(?P&lt;username&gt;\\w+)/$&apos;, views.bio, name=&apos;bio&apos;), re_path(r&apos;^weblog/&apos;, include(&apos;blog.urls&apos;)), ...] 该route参数应该是一个字符串或 gettext_lazy()，其中包含与Python的兼容的正则表达式 re模块。字符串通常使用原始字符串语法（r&#39;&#39;），以便它们可以包含序列，\\d而无需使用另一个反斜杠转义反斜杠。进行匹配时，将正则表达式中捕获的组传递给视图 - 如果组已命名，则作为命名参数，否则作为位置参数。值以字符串形式传递，不进行任何类型转换。 的view，kwargs和name参数是一样的 path() 3.include()include（module，namespace = None） include（pattern_list） include（（pattern_list，app_namespace），namespace = None） 一个函数，它将完整的Python导入路径带到另一个URLconf模块，该模块应该“包含”在这个地方。可选地，还可以指定将包括条目的应用程序命名空间和实例命名空间。 通常，应用程序命名空间应由包含的模块指定。如果设置了应用程序命名空间，则该namespace参数可用于设置不同的实例命名空间。 include() 也接受返回URL模式的iterable或包含此类iterable的2元组以及应用程序命名空间的名称作为参数。 More Actions参数： module - URLconf模块（或模块名称） namespace（str） - 包含的URL条目的实例名称空间 pattern_list - Iterable path()和/或re_path()实例。 app_namespace（str） - 包含的URL条目的应用程序命名空间 4.register_converter()register_converter（converter，type_name） 注册转换器以在s中使用的功能。path route 该converter参数是一个转换器类，并且type_name是在路径模式来使用转换器的名称。 URLconfs中使用的函数static() static.``static（前缀，视图= django.views.static.serve，** kwargs) Helper函数在调试模式下返回服务文件的URL模式： 123456from django.conf import settingsfrom django.conf.urls.static import staticurlpatterns = [ # ... the rest of your URLconf goes here ...] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) URL调度程序干净，优雅的URL方案是高质量Web应用程序中的重要细节。Django允许您根据需要设计URL，没有框架限制。 没有.php或没有.cgi必要，当然也没有 0,2097,1-1-1928,00废话。 概述要设计应用程序的URL，可以创建一个非正式的称为URLconf（URL配置）的Python模块 。此模块是纯Python代码，是URL路径表达式与Python函数（您的视图）之间的映射。 该映射可以根据需要缩短或缩短。它可以引用其他映射。而且，因为它是纯Python代码，所以它可以动态构建。 Django还提供了一种根据活动语言翻译URL的方法，详细的可以看官方文档。 Django如何处理请求当用户从Django支持的站点请求页面时，这是系统遵循的算法，以确定要执行的Python代码： Django确定要使用的根URLconf模块。通常，这是ROOT_URLCONF设置的值，但如果传入 HttpRequest对象具有urlconf属性（由中间件设置），则将使用其值代替 ROOT_URLCONF设置。 Django加载Python模块并查找变量 urlpatterns。这应该是Python列表django.urls.path() 和/或django.urls.re_path()实例。 Django按顺序遍历每个URL模式，并在匹配请求的URL的第一个模式停止。 一旦其中一个URL模式匹配，Django就会导入并调用给定的视图，这是一个简单的Python函数（或基于 类的视图 ）。视图传递以下参数： 一个例子HttpRequest。 如果匹配的URL模式未返回任何命名组，则正则表达式中的匹配将作为位置参数提供。 关键字参数由路径表达式匹配的任何命名部分组成，由或者 可选kwargs参数中指定的任何参数覆盖 。django.urls.path()``django.urls.re_path() 如果没有URL模式匹配，或者在此过程中的任何点期间引发异常，Django将调用适当的错误处理视图。请参阅下面的错误处理。 示例这是一个示例URLconf： 12345678910from django.urls import pathfrom . import viewsurlpatterns = [ path(&apos;articles/2003/&apos;, views.special_case_2003), path(&apos;articles/&lt;int:year&gt;/&apos;, views.year_archive), path(&apos;articles/&lt;int:year&gt;/&lt;int:month&gt;/&apos;, views.month_archive), path(&apos;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&apos;, views.article_detail),] 笔记： 要从URL捕获值，请使用尖括号。 捕获的值可以选择包括转换器类型。例如，用于 &lt;int:name&gt;捕获整数参数。如果未包含转换器/，则匹配除字符之外的任何字符串。 没有必要添加前导斜杠，因为每个URL都有。例如，它articles不是/articles。 示例请求： 请求/articles/2005/03/与列表中的第三个条目匹配。Django会调用该函数 。views.month_archive(request, year=2005,month=3) /articles/2003/将匹配列表中的第一个模式，而不是第二个模式，因为模式是按顺序测试的，第一个是第一个要通过的测试。随意利用订单插入这样的特殊情况。在这里，Django会调用该函数 views.special_case_2003(request) /articles/2003 不匹配任何这些模式，因为每个模式都要求URL以斜杠结尾。 /articles/2003/03/building-a-django-site/将匹配最终模式。Django会调用该函数 。views.article_detail(request,year=2003, month=3, slug=&quot;building-a-django-site&quot;) 路径转换器默认情况下，以下路径转换器可用： str- 匹配除路径分隔符之外的任何非空字符串&#39;/&#39;。如果转换器未包含在表达式中，则这是默认值。 int - 匹配零或任何正整数。返回一个int。 slug - 匹配由ASCII字母或数字组成的任何slug字符串，以及连字符和下划线字符。例如， building-your-1st-django-site。 uuid - 匹配格式化的UUID。要防止多个URL映射到同一页面，必须包含短划线，并且字母必须为小写。例如，075194d3-6885-417e-a8a8-6c931e272f00。返回一个 UUID实例。 path- 匹配任何非空字符串，包括路径分隔符 &#39;/&#39;。这允许您匹配完整的URL路径，而不仅仅是URL路径的一部分str。 注册自定义路径转换器对于更复杂的匹配要求，您可以定义自己的路径转换器。 转换器是一个包含以下内容的类： 一个regexclass属性，作为字符串。 甲方法，它处理匹配的字符串转换成要传递到视图函数的类型。如果它不能转换给定值，它应该提高。to_python(self,value)``ValueError 一种方法，用于处理将Python类型转换为要在URL中使用的字符串。to_url(self, value) 例如： 12345678class FourDigitYearConverter: regex = &apos;[0-9]&#123;4&#125;&apos; def to_python(self, value): return int(value) def to_url(self, value): return &apos;%04d&apos; % value 使用register_converter()以下命令在URLconf中注册自定义转换器类 ： 1234567891011from django.urls import path, register_converterfrom . import converters, viewsregister_converter(converters.FourDigitYearConverter, &apos;yyyy&apos;)urlpatterns = [ path(&apos;articles/2003/&apos;, views.special_case_2003), path(&apos;articles/&lt;yyyy:year&gt;/&apos;, views.year_archive), ...] 使用正则表达式如果路径和转换器语法不足以定义URL模式，则还可以使用正则表达式。为此，请使用 re_path()而不是path()。 在Python正则表达式中，命名正则表达式组的语法是(?P&lt;name&gt;pattern)，组name的名称，并且 pattern是要匹配的模式。 这是前面的示例URLconf，使用正则表达式重写： 12345678910from django.urls import path, re_pathfrom . import viewsurlpatterns = [ path(&apos;articles/2003/&apos;, views.special_case_2003), re_path(r&apos;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&apos;, views.year_archive), re_path(r&apos;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&apos;, views.month_archive), re_path(r&apos;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[\\w-]+)/$&apos;, views.article_detail),] 这完成了与前一个示例大致相同的事情，除了： 匹配的确切网址稍微受限制。例如，年份10000将不再匹配，因为年份整数被限制为恰好四位数。 无论正则表达式的匹配类型如何，每个捕获的参数都将作为字符串发送到视图。 从使用切换path()到 re_path()反之亦然，特别重要的是要注意视图参数的类型可能会发生变化，因此您可能需要调整视图。 使用未命名的正则表达式组除了命名组语法之外，例如(?P&lt;year&gt;[0-9]{4})，您还可以使用较短的未命名组，例如([0-9]{4})。 不特别推荐这种用法，因为它更容易在匹配的预期含义和视图的参数之间意外引入错误。 在任何一种情况下，建议在给定的正则表达式中仅使用一种样式。当两种样式混合使用时，将忽略任何未命名的组，并且只将命名组传递给视图函数。 嵌套参数正则表达式允许嵌套参数，Django将解析它们并将它们传递给视图。反转时，Django将尝试填充所有外部捕获的参数，忽略任何嵌套捕获的参数。考虑以下URL模式，它们可选地采用页面参数： 123456from django.urls import re_pathurlpatterns = [ re_path(r&apos;^blog/(page-(\\d+)/)?$&apos;, blog_articles), # bad re_path(r&apos;^comments/(?:page-(?P&lt;page_number&gt;\\d+)/)?$&apos;, comments), # good] 两种模式都使用嵌套参数并将解析：例如， blog/page-2/将导致blog_articles与两个位置参数匹配：page-2/和2。第二个模式comments将匹配comments/page-2/关键字参数 page_number设置为2.在这种情况下，外部参数是非捕获参数(?:...)。 的blog_articles视图需要扭转最外捕获的参数， page-2/或者在这种情况下没有参数，而comments可与任何参数或值被反转page_number。 嵌套捕获的参数在视图参数和URL之间创建强耦合，如下所示blog_articles：视图接收URL（page-2/）的一部分而不是视图感兴趣的值。这种耦合在反转时更加明显，因为反转我们需要传递一段URL而不是页码的视图。 根据经验，只捕获视图需要使用的值，并在正则表达式需要参数但视图忽略它时使用非捕获参数。 URLconf搜索的内容URLconf将搜索请求的URL，作为普通的Python字符串。这不包括GET或POST参数或域名。 例如，在请求中https://www.example.com/myapp/，URLconf将查找myapp/。 在请求中https://www.example.com/myapp/?page=3，URLconf将查找myapp/。 URLconf不查看请求方法。换句话说，所有的请求方法- ，，POST 等-将被路由到相同的URL相同的功能。GET``HEAD 指定视图参数的默认值一个方便的技巧是为视图的参数指定默认参数。这是一个示例URLconf和视图： 1234567891011121314# URLconffrom django.urls import pathfrom . import viewsurlpatterns = [ path(&apos;blog/&apos;, views.page), path(&apos;blog/page&lt;int:num&gt;/&apos;, views.page),]# View (in blog/views.py)def page(request, num=1): # Output the appropriate page of blog entries, according to num. ... 在上面的示例中，两个URL模式都指向同一个视图 views.page- 但第一个模式不会从URL捕获任何内容。如果第一个模式匹配，该page()函数将使用它的默认参数num，1。如果第二个模式匹配， page()将使用num捕获的任何值。 表现a中的每个正则表达式在urlpatterns第一次访问时编译。这使得系统非常快。 urlpatterns变量的语法urlpatterns应该是Python列表path()和/或 re_path()实例。 错误处理当Django找不到所请求URL的匹配项时，或者引发异常时，Django会调用错误处理视图。 用于这些情况的视图由四个变量指定。它们的默认值应该足以满足大多数项目的需要，但可以通过覆盖它们的默认值来进一步自定义。 可以在根URLconf中设置此类值。在任何其他URLconf中设置这些变量将不起作用。 值必须是callables或字符串，表示应该调用以处理手头错误条件的视图的完整Python导入路径。 变量是： handler400 handler403 handler404 handler500 包括其他的URLconf在任何时候，您urlpatterns都可以“包含”其他URLconf模块。这基本上是“根”一组URL低于其他URL。 例如，这里是Django网站本身的URLconf的摘录。它包括许多其他URLconf： 12345678from django.urls import include, pathurlpatterns = [ # ... snip ... path(&apos;community/&apos;, include(&apos;aggregator.urls&apos;)), path(&apos;contact/&apos;, include(&apos;contact.urls&apos;)), # ... snip ...] 每当Django遇到时include()，它都会删除与该点匹配的URL的任何部分，并将剩余的字符串发送到包含的URLconf以进行进一步处理。 另一种可能性是通过使用path()实例列表来包含其他URL模式 。例如，考虑这个URLconf： 12345678910111213141516from django.urls import include, pathfrom apps.main import views as main_viewsfrom credit import views as credit_viewsextra_patterns = [ path(&apos;reports/&apos;, credit_views.report), path(&apos;reports/&lt;int:id&gt;/&apos;, credit_views.report), path(&apos;charge/&apos;, credit_views.charge),]urlpatterns = [ path(&apos;&apos;, main_views.homepage), path(&apos;help/&apos;, include(&apos;apps.help.urls&apos;)), path(&apos;credit/&apos;, include(extra_patterns)),] 在此示例中，/credit/reports/URL将由credit_views.report()Django视图处理 。 这可用于从重复使用单个模式前缀的URLconf中删除冗余。例如，考虑这个URLconf： 123456789from django.urls import pathfrom . import viewsurlpatterns = [ path(&apos;&lt;page_slug&gt;-&lt;page_id&gt;/history/&apos;, views.history), path(&apos;&lt;page_slug&gt;-&lt;page_id&gt;/edit/&apos;, views.edit), path(&apos;&lt;page_slug&gt;-&lt;page_id&gt;/discuss/&apos;, views.discuss), path(&apos;&lt;page_slug&gt;-&lt;page_id&gt;/permissions/&apos;, views.permissions),] 我们可以通过仅指定公共路径前缀一次并对不同的后缀进行分组来改进这一点： 1234567891011from django.urls import include, pathfrom . import viewsurlpatterns = [ path(&apos;&lt;page_slug&gt;-&lt;page_id&gt;/&apos;, include([ path(&apos;history/&apos;, views.history), path(&apos;edit/&apos;, views.edit), path(&apos;discuss/&apos;, views.discuss), path(&apos;permissions/&apos;, views.permissions), ])),] 捕获的参数包含的URLconf从父URLconf接收任何捕获的参数，因此以下示例有效： 123456789101112131415# In settings/urls/main.pyfrom django.urls import include, pathurlpatterns = [ path(&apos;&lt;username&gt;/blog/&apos;, include(&apos;foo.urls.blog&apos;)),]# In foo/urls/blog.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path(&apos;&apos;, views.blog.index), path(&apos;archive/&apos;, views.blog.archive),] 在上面的示例中，捕获的&quot;username&quot;变量按预期传递给包含的URLconf。 传递额外选项来查看功能URLconfs有一个钩子，允许您将额外的参数作为Python字典传递给视图函数。 该path()函数可以采用可选的第三个参数，该参数应该是传递给视图函数的额外关键字参数的字典。 例如： 123456from django.urls import pathfrom . import viewsurlpatterns = [ path(&apos;blog/&lt;int:year&gt;/&apos;, views.year_archive, &#123;&apos;foo&apos;: &apos;bar&apos;&#125;),] 在这个例子中，对于请求/blog/2005/，Django将调用 。views.year_archive(request, year=2005, foo=&#39;bar&#39;) 在联合框架中使用此技术 将元数据和选项传递给视图。 处理冲突 可以使用URL模式捕获命名关键字参数，并在其额外参数字典中传递具有相同名称的参数。发生这种情况时，将使用字典中的参数而不是URL中捕获的参数。 将额外选项传递给include()同样，您可以传递额外的选项，include()并且包含的URLconf中的每一行都将传递额外的选项。 例如，这两个URLconf集在功能上是相同的： 设置一个： 123456789101112131415# main.pyfrom django.urls import include, pathurlpatterns = [ path(&apos;blog/&apos;, include(&apos;inner&apos;), &#123;&apos;blog_id&apos;: 3&#125;),]# inner.pyfrom django.urls import pathfrom mysite import viewsurlpatterns = [ path(&apos;archive/&apos;, views.archive), path(&apos;about/&apos;, views.about),] 设置二： 123456789101112131415# main.pyfrom django.urls import include, pathfrom mysite import viewsurlpatterns = [ path(&apos;blog/&apos;, include(&apos;inner&apos;)),]# inner.pyfrom django.urls import pathurlpatterns = [ path(&apos;archive/&apos;, views.archive, &#123;&apos;blog_id&apos;: 3&#125;), path(&apos;about/&apos;, views.about, &#123;&apos;blog_id&apos;: 3&#125;),] 请注意，无论行的视图是否实际接受这些选项为有效，额外选项将始终传递到包含的URLconf中的每一行。因此，只有在您确定所包含的URLconf中的每个视图都接受您传递的额外选项时，此技术才有用。 URL的反向解析在处理Django项目时，通常需要获得最终形式的URL，以嵌入生成的内容（视图和资产URL，向用户显示的URL等）或处理服务器上的导航流。方（重定向等） 强烈希望避免对这些URL进行硬编码（这是一种费力的，不可扩展且容易出错的策略）。同样危险的是设计临时机制来生成与URLconf描述的设计并行的URL，这可能导致生成随时间变得陈旧的URL。 换句话说，需要的是DRY机制。除了其他优点之外，它还允许进行URL设计的演变，而无需遍历所有项目源代码来搜索和替换过时的URL。 我们可用于获取URL的主要信息是负责处理URL的视图的标识（例如名称）。必须参与查找正确URL的其他信息是视图参数的类型（位置，关键字）和值。 Django提供了一个解决方案，使URL映射器成为URL设计的唯一存储库。您使用URLconf提供它，然后它可以在两个方向上使用： 从用户/浏览器请求的URL开始，它调用正确的Django视图，提供它可能需要的任何参数以及从URL中提取的值。 从标识相应的Django视图以及将传递给它的参数值开始，获取关联的URL。 第一个是我们在前面几节中讨论过的用法。第二个是所谓的URL反向解析，反向URL匹配，反向URL查找或简单的URL反转。 Django提供了用于执行URL反转的工具，这些工具匹配需要URL的不同层： 在模板中：使用url模板标记。 在Python代码中：使用该reverse()函数。 在与处理Django模型实例的URL相关的更高级代码中：该get_absolute_url()方法。 示例再次考虑这个URLconf条目： 123456789from django.urls import pathfrom . import viewsurlpatterns = [ #... path(&apos;articles/&lt;int:year&gt;/&apos;, views.year_archive, name=&apos;news-year-archive&apos;), #...] 根据这种设计，对应于年度归档文件的URL NNNN 是/articles/&lt;nnnn&gt;/。 您可以使用以下方法在模板代码中获取这些： 1234567&lt;a href=&quot;&#123;% url &apos;news-year-archive&apos; 2012 %&#125;&quot;&gt;2012 Archive&lt;/a&gt;&#123;# Or with the year in a template context variable: #&#125;&lt;ul&gt;&#123;% for yearvar in year_list %&#125;&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;news-year-archive&apos; yearvar %&#125;&quot;&gt;&#123;&#123; yearvar &#125;&#125; Archive&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 或者在Python代码中： 12345678from django.http import HttpResponseRedirectfrom django.urls import reversedef redirect_to_year(request): # ... year = 2006 # ... return HttpResponseRedirect(reverse(&apos;news-year-archive&apos;, args=(year,))) 如果由于某种原因决定应该更改发布年度文章档案的内容的URL，那么您只需要更改URLconf中的条目。 在视图具有通用性的某些情况下，URL和视图之间可能存在多对一关系。对于这些情况，当反转URL时，视图名称不是足够好的标识符。阅读下一节，了解Django为此提供的解决方案。 命名URL模式要执行URL反转，您需要使用命名URL模式， 如上面的示例所示。用于URL名称的字符串可以包含您喜欢的任何字符。您不限于有效的Python名称。 命名URL模式时，请选择不太可能与其他应用程序选择的名称冲突的名称。如果您调用URL模式comment 而另一个应用程序执行相同操作，则reverse()找到的URL 取决于项目urlpatterns列表中最后一个模式。 在URL名称上添加前缀（可能是从应用程序名称派生的（例如myapp-comment代替comment））可以减少冲突的可能性。 如果要覆盖视图，可以故意选择与其他应用程序相同的URL名称。例如，一个常见的用例是覆盖 LoginView。Django和大多数第三方应用程序的部分假定此视图具有名称的URL模式 login。如果你有一个自定义登录查看，并给它的URL名称login， reverse()将只要它在找到你的自定义视图 urlpatterns之后，django.contrib.auth.urls包括（如果这是包含在所有）。 如果参数不同，您也可以对多个URL模式使用相同的名称。除URL名称外，还reverse()匹配参数的数量和关键字参数的名称。 URL命名空间介绍即使不同的应用程序使用相同的URL名称，URL命名空间也允许您唯一地反转。对于第三方应用程序来说，始终使用命名空间URL是一种很好的做法（正如我们在教程中所做的那样）。同样，如果部署了多个应用程序实例，它还允许您反向URL。换句话说，由于单个应用程序的多个实例将共享命名URL，因此命名空间提供了一种将这些命名URL分开的方法。 正确使用URL命名空间的Django应用程序可以针对特定站点多次部署。例如，[django.contrib.admin]有一个 [AdminSite]类允许您轻松 部署多个admin实例。在后面的示例中，我们将讨论在两个不同位置从教程部署民意调查应用程序的想法，以便我们可以为两个不同的受众（作者和发布者）提供相同的功能。 URL命名空间分为两部分，两部分都是字符串： 应用命名空间 这描述了正在部署的应用程序的名称。单个应用程序的每个实例都具有相同的应用程序命名空间。例如，Django的管理应用程序具有可预测的应用程序命名空间&#39;admin&#39;。 实例命名空间 这标识了应用程序的特定实例。实例名称空间在整个项目中应该是唯一的。但是，实例名称空间可以与应用程序名称空间相同。这用于指定应用程序的默认实例。例如，默认的Django管理实例的实例名称空间为&#39;admin&#39;。 命名空间URL使用&#39;:&#39;运算符指定。例如，使用引用管理应用程序的主索引页面&#39;admin:index&#39;。这表示名称空间&#39;admin&#39;和命名URL &#39;index&#39;。 命名空间也可以嵌套。命名URL &#39;sports:polls:index&#39;将查找&#39;index&#39;在命名空间中命名的模式，该模式&#39;polls&#39;本身在顶级命名空间中定义&#39;sports&#39;。 反转命名空间的URL当给出&#39;polls:index&#39;要解析的命名空间URL（例如）时，Django将完全限定名称拆分为多个部分，然后尝试以下查找： 首先，Django寻找匹配的应用程序命名空间（在本例中&#39;polls&#39;）。这将产生该应用程序的实例列表。 如果定义了当前应用程序，Django会查找并返回该实例的URL解析程序。可以使用 函数的current_app参数指定当前应用程序reverse()。 该url模板标签使用当前解决视图在当前应用程序的命名空间 [RequestContext]。您可以通过在[request.current_app]属性上设置当前应用程序来覆盖此默认值。 如果没有当前的申请。Django寻找默认的应用程序实例。默认应用程序实例是具有与应用程序命名空间匹配的实例命名空间的实例（在此示例中，是被调用的实例）。polls``&#39;polls&#39; 如果没有默认的应用程序实例，Django将选择最后部署的应用程序实例，无论其实例名称是什么。 如果提供的命名空间与步骤1 中的应用程序命名空间不匹配，Django将尝试直接查找命名空间作为 实例命名空间。 如果存在嵌套命名空间，则会对命名空间的每个部分重复这些步骤，直到只有视图名称未解析为止。然后，视图名称将被解析为已找到的命名空间中的URL。 示例要显示此解决方案策略，请考虑polls本教程中应用程序的两个实例的示例：一个调用&#39;author-polls&#39; ，一个调用&#39;publisher-polls&#39;。假设我们已经增强了该应用程序，以便在创建和显示轮询时考虑实例名称空间。 urls.py 123456from django.urls import include, pathurlpatterns = [ path(&apos;author-polls/&apos;, include(&apos;polls.urls&apos;, namespace=&apos;author-polls&apos;)), path(&apos;publisher-polls/&apos;, include(&apos;polls.urls&apos;, namespace=&apos;publisher-polls&apos;)),] polls/urls.py 12345678910from django.urls import pathfrom . import viewsapp_name = &apos;polls&apos;urlpatterns = [ path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;), path(&apos;&lt;int:pk&gt;/&apos;, views.DetailView.as_view(), name=&apos;detail&apos;), ...] 使用此设置，可以进行以下查找： 如果其中一个实例是最新的 - 例如，如果我们在实例中呈现详细信息页面&#39;author-polls&#39;- &#39;polls:index&#39;将解析为实例的索引页面&#39;author-polls&#39;; 即以下两个都将导致&quot;/author-polls/&quot;。 在基于类的视图的方法中： 1reverse(&apos;polls:index&apos;, current_app=self.request.resolver_match.namespace) 并在模板中： 1&#123;% url &apos;polls:index&apos; %&#125; 如果没有当前实例 - 例如，如果我们在网站上的其他位置呈现页面 - &#39;polls:index&#39;将解析为最后一个注册的实例polls。由于没有默认实例（实例名称空间&#39;polls&#39;），因此polls将使用注册的最后一个实例。这将是&#39;publisher-polls&#39;因为它在最后宣布urlpatterns。 &#39;author-polls:index&#39;将始终解析为实例的索引页面 &#39;author-polls&#39;（同样适用于&#39;publisher-polls&#39;）。 如果还有一个默认实例 - 即一个名为的实例&#39;polls&#39;- 上面的唯一更改是在没有当前实例的情况下（上面列表中的第二项）。在这种情况下，&#39;polls:index&#39; 将解析为默认实例的索引页，而不是最后声明的实例urlpatterns。 URL命名空间和包含的URLconf包含的URLconf的应用程序命名空间可以用两种方式指定。 首先，您可以app_name在包含的URLconf模块中设置属性，该属性与属性处于同一级别urlpatterns。您必须将实际模块或对模块的字符串引用传递给它include()，而不是urlpatterns它自己的列表。 polls/urls.py 12345678910from django.urls import pathfrom . import viewsapp_name = &apos;polls&apos;urlpatterns = [ path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;), path(&apos;&lt;int:pk&gt;/&apos;, views.DetailView.as_view(), name=&apos;detail&apos;), ...] urls.py 12345from django.urls import include, pathurlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)),] 定义的URL polls.urls将具有应用程序命名空间polls。 其次，您可以包含一个包含嵌入式命名空间数据的对象。如果include()是列表path()或 re_path()实例，则该对象中包含的URL将添加到全局命名空间。但是，您还可以include()使用包含以下内容的2元组： 1(&lt;list of path()/re_path() instances&gt;, &lt;application namespace&gt;) 例如： 123456789101112from django.urls import include, pathfrom . import viewspolls_patterns = ([ path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;), path(&apos;&lt;int:pk&gt;/&apos;, views.DetailView.as_view(), name=&apos;detail&apos;),], &apos;polls&apos;)urlpatterns = [ path(&apos;polls/&apos;, include(polls_patterns)),] 这将在指定的应用程序命名空间中包含指定的URL模式。 可以使用namespace参数to 指定实例名称空间include()。如果未指定实例名称空间，则它将默认为包含的URLconf的应用程序名称空间。这意味着它也将是该命名空间的默认实例。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Django","slug":"技术栈/Django","permalink":"https://angeszhu.github.io/categories/技术栈/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://angeszhu.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://angeszhu.github.io/tags/Web框架/"},{"name":"测试开发","slug":"测试开发","permalink":"https://angeszhu.github.io/tags/测试开发/"}]},{"title":"配置（Setting）","slug":"django-setting","date":"2019-06-03T13:17:03.000Z","updated":"2019-06-03T13:43:15.387Z","comments":true,"path":"2019/06/03/django-setting/","link":"","permalink":"https://angeszhu.github.io/2019/06/03/django-setting/","excerpt":"","text":"Django的项目设置（Setting）1.基础DJANGO_SETTING_MODULE环境变量： 让settings模块被包含到python可以找到的目录下，开发情况下不需要，我们通常会在当前文件夹运行，python可以搜索到。 如果需要运行在其他服务器上，就必须指定DJANGO_SETTINGS_MODULE变量。 2.默认设定一个django的settings文件不需要我们手动去设置所有项目，因为系统已经默认设置好了。我们只需要修改我们使用的设 定就好了。默认的设置在django/conf/global_settings.py文件中。 django在编译时，先载入global_settings.py中的配置，然后加载指定的settings文件，重写改变的设定。 好了，步入正文。 前面的随笔中我们经常会改setting配置也经常将一些配置混淆今天主要是将一些常见的配置做一个汇总。 3.setting配置汇总1）项目通过os模块，获取当前项目在系统的具体路径 12345import os# 项目路径# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 2）密钥配置随机值，在项目创建的时候生成，主要用于重要数据的加密处理，提高系统的安全性， 主要用于用户密码，CSRF机制和会话Session等数据加密。 1SECRET_KEY = &apos;g(eqo*xohqzl9-&amp;&amp;k)-+@5^&amp;_xd+9s9muhe7iy#6$-gv_s_e#f&apos; 3）调试模式和域名访问权限调试模式为布尔值，在开发调试过程中，自动检测代码是否发生更改，根据检测结果执行是否刷新重启系统。 域名访问权限，设置可访问的域名，默认值为空。 当开启调试模式时，可访问域名为空，则项目只允许以loaclhost或者127.0.0.1在浏览器访问。 在生产环境配置时，需要关闭调试模式，并且，此时的ALLOWED_HOSTS为必填项。 ALLOWED_HOSTS = [‘*’] 表示允许所有域名访问。 12345678# SECURITY WARNING: don&apos;t run with debug turned on in production!# 生产环境配置DEBUG = FalseALLOWED_HOSTS = [&apos;*&apos;] # 测试环境配置DEBUG = TrueALLOWED_HOSTS = [] 4）app路径app列表，django项目里，包含了哪些内容。 123456789INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, # 内置的后台管理系统 &apos;django.contrib.auth&apos;, # 内置的用户认证系统 &apos;django.contrib.contenttypes&apos;, # 记录项目中所有model元数据（Django自带的ORM框架） &apos;django.contrib.sessions&apos;, # 会话功能 &apos;django.contrib.messages&apos;, # 消息提示功能 &apos;django.contrib.staticfiles&apos;, # 查找静态资源路径 &apos;study.apps.StudyConfig&apos;, # 自定义App] 5）中间件中间件（MIDDLEWARE）是处理Django的request和response对象的钩子。 他的主要作用是处理用户请求信息。 123456789MIDDLEWARE = [ &apos;django.middleware.security.SecurityMiddleware&apos;, # 内置的安全机制，保护用户和网站的通信安全 &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, # 会话session功能 &apos;django.middleware.common.CommonMiddleware&apos;, # 处理请求信息，规范化请求内容。 &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, # 开启CSRF防护功能 &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, # 开启内置的用户认证系统 &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, # 开启内置的信息提示功能 &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, # 防止恶意程序点击劫持。] 6）模板路径123456789101112131415161718TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, # 定义模板引擎，用户识别模板里面的变量和指令 &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)] # 设置模板所在的路径，可配置多个路径 # 数据类型：列表list，[os.path.join(BASE_DIR, &apos;templates&apos;),os.path.join(BASE_DIR, &apos;study/templates&apos;)] , &apos;APP_DIRS&apos;: True, # 是否在app中查找模板文件 # 用于填充在RequestContext中上下文的调用函数，一般情况不用修改 &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 7）数据库配置如果使用django的默认sqlite3数据库则不需要改。 django一共提供了4种数据引擎，每一种引擎对应一种数据库。 1234django.db.backends.sqlite3django.db.backends.postgresqldjango.db.backends.mysqldjango.db.backends.oracle 123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 如果使用mysql数据库需要将上述数据库注掉修改如下 12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;blog&apos;, # 数据库名称 &apos;USER&apos;: &apos;root&apos;, #你的数据库用户名 &apos;PASSWORD&apos;:&apos;&apos; , #你的数据库密码 &apos;HOST&apos;:&apos;&apos;, #你的数据库主机，留空默认为localhost &apos;PORT&apos;:&apos;3306&apos; #你的数据库端口 &#125;&#125; 并且需要在应用的init.py文件添加 12import pymysqlpymysql.install_as_MySQLdb() 8）语言配置django的目录下，django/conf/locale，可以找到很多的语言包，选择你想要配置的语言包添加进去配置。 zh_Hans代表中文简体 zh_Hant代表中文繁体 12LANGUAGE_CODE = &apos;en-us&apos; # 默认英文LANGUAGE_CODE = &apos;zh-Hans&apos; # 修改为中文 9）时间配置12TIME_ZONE = &apos;UTC&apos;TIME_ZONE = &apos;Asia/Shanghai&apos; 10）时区设置​ 因为Mysql存储的时间不能灵活设置时区，不像datetime对象有一项参数专门指定时区，所以为了统一全球的时间，必须使用国际标准时间UTC，否则就会乱套。所有时间在存如数据库前，必须转换成UTC时间。比如北京时间8点，存入mysql变成0点（UTC）。 一般不跨时区的应用，可以不使用时区，即在settings.py设置 123USE_TZ = TrueUSE_TZ = False 11）静态文件目录这个路径只用于django提供的静态资源加载服务。 若部署之后，则这里的配置需要更改。 1234567STATIC_URL = &apos;/static/&apos; #调用时目录STATICFILES_DIRS=[ os.path.join(BASE_DIR,&quot;static&quot;), #具体路径]# 静态资源文件STATICFILES_DIRS = (os.path.join(BASE_DIR, &quot;statics&quot;),) # 现添加的配置,这里是元组，注意逗号# 我们一般只用 STATIC_URL，但STATIC_URL会按着你的STATICFILES_DIRS去找 12）如果数据库中的UserInfo(用户表)继承django内置AbstractUser1）model需导入 1from django.contrib.auth.models import AbstractUser 2）配置文件 1AUTH_USER_MODEL = &quot;应用名.UserInfo&quot; 13）session存储的相关配置1）数据库配置（默认） 1234567891011Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。配置 settings.py SESSION_ENGINE = &apos;django.contrib.sessions.backends.db&apos; # 引擎（默认） SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认） SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径（默认） SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认） SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认） SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认） SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认） SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） 2）缓存配置 1234567891011配置 settings.py SESSION_ENGINE = &apos;django.contrib.sessions.backends.cache&apos; # 引擎 SESSION_CACHE_ALIAS = &apos;default&apos; # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 3）默认配置 1234567891011配置 settings.py SESSION_ENGINE = &apos;django.contrib.sessions.backends.file&apos; # 引擎 SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存 注意： 1）也可以自定义配置 但是自定义的配置都要写到配置文件最后 代码中使用时可以导入配置 12from django.conf import settingssettings.配置名 2）上面所有配置都是针对特定问题需要修改的 系统默认配置不做说明 3）上面配置只是前面django系列随笔所遇到的常用配置 后续所遇配置都会逐步在此随笔中持续添加跟新 4.日志配置详解1）Logger记录器是记录系统的入口点。每个记录器都是一个命名存储桶，可以将消息写入进行处理。 记录器配置为具有日志级别。此日志级别描述了记录器将处理的消息的严重性。Python定义了以下日志级别： DEBUG：用于调试目的的低级系统信息 INFO：一般系统信息 WARNING：描述已发生的小问题的信息。 ERROR：描述已发生的主要问题的信息。 CRITICAL：描述已发生的严重问题的信息。 一旦记录器确定需要处理消息，它就会传递给处理程序。 2）处理程序处理程序是确定记录器中每条消息发生情况的引擎。它描述了特定的日志记录行为，例如将消息写入屏幕，文件或网络套接字。 与记录器一样，处理程序也具有日志级别。如果日志记录的日志级别未达到或超过处理程序的级别，则处理程序将忽略该消息。 记录器可以有多个处理程序，每个处理程序可以具有不同的日志级别。以这种方式，可以根据消息的重要性提供不同形式的通知。 3）过滤器 过滤器用于提供对从记录器到处理程序的日志记录传递的额外控制。 默认情况下，将处理满足日志级别要求的任何日志消息。但是，通过安装筛选器，您可以在日志记录过程中添加其他条件 例如，您可以安装仅允许ERROR发出来自特定源的消息的过滤器。 过滤器还可用于在发出之前修改日志记录。 例如，如果满足一组特定条件，您可以编写一个过滤器，将ERROR日志记录降级 为WARNING记录。 过滤器可以安装在记录器或处理器上; 可以在链中使用多个过滤器来执行多个过滤操作。 4）格式化程序​ 最终，日志记录需要呈现为文本。格式化程序描述该文本的确切格式。格式化程序通常由包含LogRecord属性的Python格式化字符串组成 ; 但是，您也可以编写自定义格式化程序来实现特定的格式化行为。 5）使用日志记录配置记录器，处理程序，过滤器和格式化程序后，需要将日志记录调用放入代码中。使用日志框架非常简单。这是一个例子： 1234567891011# import the logging libraryimport logging# Get an instance of a loggerlogger = logging.getLogger(__name__)def my_view(request, arg1, arg): ... if bad_mojo: # Log an error message logger.error(&apos;Something went wrong!&apos;) 6）配置日志记录常用配置，日志配置例子2个，以供大家参考。 12345import timecur_path = os.path.dirname(os.path.realpath(__file__)) # log_path是存放日志的路径log_path = os.path.join(os.path.dirname(cur_path), &apos;logs&apos;)if not os.path.exists(log_path): os.mkdir(log_path) # 如果不存在这个logs文件夹，就自动创建一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778BASE_LOG_DIR = os.path.join(BASE_DIR, &quot;log&quot;)LOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: &#123; &apos;standard&apos;: &#123; &apos;format&apos;: &apos;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&apos; &apos;[%(levelname)s][%(message)s]&apos; &#125;, &apos;simple&apos;: &#123; &apos;format&apos;: &apos;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&apos; &#125;, &apos;collect&apos;: &#123; &apos;format&apos;: &apos;%(message)s&apos; &#125; &#125;, &apos;filters&apos;: &#123; &apos;require_debug_true&apos;: &#123; &apos;()&apos;: &apos;django.utils.log.RequireDebugTrue&apos;, &#125;, &#125;, &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; &apos;level&apos;: &apos;DEBUG&apos;, &apos;filters&apos;: [&apos;require_debug_true&apos;], # 只有在Django debug为True时才在屏幕打印日志 &apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;simple&apos; &#125;, &apos;SF&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, # 保存到文件，根据文件大小自动切 &apos;filename&apos;: os.path.join(BASE_LOG_DIR, &quot;xxx_info.log&quot;), # 日志文件 &apos;maxBytes&apos;: 1024 * 1024 * 50, # 日志大小 50M &apos;backupCount&apos;: 3, # 备份数为3 xx.log --&gt; xx.log.1 --&gt; xx.log.2 --&gt; xx.log.3 &apos;formatter&apos;: &apos;standard&apos;, &apos;encoding&apos;: &apos;utf-8&apos;, &#125;, &apos;TF&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;class&apos;: &apos;logging.handlers.TimedRotatingFileHandler&apos;, # 保存到文件，根据时间自动切 &apos;filename&apos;: os.path.join(BASE_LOG_DIR, &quot;xxx_info.log&quot;), # 日志文件 &apos;backupCount&apos;: 3, # 备份数为3 xx.log --&gt; xx.log.2018-08-23_00-00-00 --&gt; xx.log.2018-08-24_00-00-00 --&gt; ... &apos;when&apos;: &apos;D&apos;, # 每天一切， 可选值有S/秒 M/分 H/小时 D/天 W0-W6/周(0=周一) midnight/如果没指定时间就默认在午夜 &apos;formatter&apos;: &apos;standard&apos;, &apos;encoding&apos;: &apos;utf-8&apos;, &#125;, &apos;error&apos;: &#123; &apos;level&apos;: &apos;ERROR&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, # 保存到文件，自动切 &apos;filename&apos;: os.path.join(BASE_LOG_DIR, &quot;xxx_err.log&quot;), # 日志文件 &apos;maxBytes&apos;: 1024 * 1024 * 5, # 日志大小 50M &apos;backupCount&apos;: 5, &apos;formatter&apos;: &apos;standard&apos;, &apos;encoding&apos;: &apos;utf-8&apos;, &#125;, &apos;collect&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, # 保存到文件，自动切 &apos;filename&apos;: os.path.join(BASE_LOG_DIR, &quot;xxx_collect.log&quot;), &apos;maxBytes&apos;: 1024 * 1024 * 50, # 日志大小 50M &apos;backupCount&apos;: 5, &apos;formatter&apos;: &apos;collect&apos;, &apos;encoding&apos;: &quot;utf-8&quot; &#125; &#125;, &apos;loggers&apos;: &#123; &apos;&apos;: &#123; # 默认的logger应用如下配置 &apos;handlers&apos;: [&apos;SF&apos;, &apos;console&apos;, &apos;error&apos;], # 上线之后可以把&apos;console&apos;移除 &apos;level&apos;: &apos;DEBUG&apos;, &apos;propagate&apos;: True, &#125;, &apos;collect&apos;: &#123; # 名为 &apos;collect&apos;的logger还单独处理 &apos;handlers&apos;: [&apos;console&apos;, &apos;collect&apos;], &apos;level&apos;: &apos;INFO&apos;, &#125; &#125;,&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970LOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: True, &apos;formatters&apos;: &#123; # 日志格式 &apos;standard&apos;: &#123; &apos;format&apos;: &apos;[%(asctime)s] [%(filename)s:%(lineno)d] [%(module)s:%(funcName)s] &apos; &apos;[%(levelname)s]- %(message)s&apos;&#125;, &apos;simple&apos;: &#123; # 简单格式 &apos;format&apos;: &apos;%(levelname)s %(message)s&apos; &#125;, &#125;, # 过滤 &apos;filters&apos;: &#123; &#125;, # 定义具体处理日志的方式 &apos;handlers&apos;: &#123; # 默认记录所有日志 &apos;default&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;filename&apos;: os.path.join(log_path, &apos;all-&#123;&#125;.log&apos;.format(time.strftime(&apos;%Y-%m-%d&apos;))), &apos;maxBytes&apos;: 1024 * 1024 * 5, # 文件大小 &apos;backupCount&apos;: 5, # 备份数 &apos;formatter&apos;: &apos;standard&apos;, # 输出格式 &apos;encoding&apos;: &apos;utf-8&apos;, # 设置默认编码，否则打印出来汉字乱码 &#125;, # 输出错误日志 &apos;error&apos;: &#123; &apos;level&apos;: &apos;ERROR&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;filename&apos;: os.path.join(log_path, &apos;error-&#123;&#125;.log&apos;.format(time.strftime(&apos;%Y-%m-%d&apos;))), &apos;maxBytes&apos;: 1024 * 1024 * 5, # 文件大小 &apos;backupCount&apos;: 5, # 备份数 &apos;formatter&apos;: &apos;standard&apos;, # 输出格式 &apos;encoding&apos;: &apos;utf-8&apos;, # 设置默认编码 &#125;, # 控制台输出 &apos;console&apos;: &#123; &apos;level&apos;: &apos;DEBUG&apos;, &apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;standard&apos; &#125;, # 输出info日志 &apos;info&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;filename&apos;: os.path.join(log_path, &apos;info-&#123;&#125;.log&apos;.format(time.strftime(&apos;%Y-%m-%d&apos;))), &apos;maxBytes&apos;: 1024 * 1024 * 5, &apos;backupCount&apos;: 5, &apos;formatter&apos;: &apos;standard&apos;, &apos;encoding&apos;: &apos;utf-8&apos;, # 设置默认编码 &#125;, &#125;, # 配置用哪几种 handlers 来处理日志 &apos;loggers&apos;: &#123; # 类型 为 django 处理所有类型的日志， 默认调用 &apos;django&apos;: &#123; &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;], &apos;level&apos;: &apos;INFO&apos;, &apos;propagate&apos;: False &#125;, # log 调用时需要当作参数传入 &apos;log&apos;: &#123; &apos;handlers&apos;: [&apos;error&apos;, &apos;info&apos;, &apos;console&apos;, &apos;default&apos;], &apos;level&apos;: &apos;INFO&apos;, &apos;propagate&apos;: True &#125;, &#125;&#125; 7）添加发送邮件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#管理员邮箱ADMINS = ( (&apos;laixintao&apos;,&apos;*******@163.com&apos;),) #非空链接，却发生404错误，发送通知MANAGERSSEND_BROKEN_LINK_EMAILS = TrueMANAGERS = ADMINS #Email设置EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_HOST= &apos;smtp.163.com&apos;#QQ邮箱SMTP服务器(邮箱需要开通SMTP服务)EMAIL_PORT= 25 #QQ邮箱SMTP服务端口EMAIL_HOST_USER = &apos;**********@163.com&apos; #我的邮箱帐号EMAIL_HOST_PASSWORD = &apos;**************&apos; #授权码EMAIL_SUBJECT_PREFIX = &apos;website&apos; #为邮件标题的前缀,默认是&apos;[django]&apos;EMAIL_USE_TLS = True #开启安全链接DEFAULT_FROM_EMAIL = SERVER_EMAIL = EMAIL_HOST_USER #设置发件人 #logging日志配置LOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: True, &apos;formatters&apos;: &#123;#日志格式 &apos;standard&apos;: &#123; &apos;format&apos;: &apos;%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s&apos;&#125; &#125;, &apos;filters&apos;: &#123;#过滤器 &apos;require_debug_false&apos;: &#123; &apos;()&apos;: &apos;django.utils.log.RequireDebugFalse&apos;, &#125; &#125;, &apos;handlers&apos;: &#123;#处理器 &apos;null&apos;: &#123; &apos;level&apos;: &apos;DEBUG&apos;, &apos;class&apos;: &apos;logging.NullHandler&apos;, &#125;, &apos;mail_admins&apos;: &#123;#发送邮件通知管理员 &apos;level&apos;: &apos;ERROR&apos;, &apos;class&apos;: &apos;django.utils.log.AdminEmailHandler&apos;, &apos;filters&apos;: [&apos;require_debug_false&apos;],# 仅当 DEBUG = False 时才发送邮件 &apos;include_html&apos;: True, &#125;, &apos;debug&apos;: &#123;#记录到日志文件(需要创建对应的目录，否则会出错) &apos;level&apos;:&apos;DEBUG&apos;, &apos;class&apos;:&apos;logging.handlers.RotatingFileHandler&apos;, &apos;filename&apos;: os.path.join(BASE_DIR, &quot;log&quot;,&apos;debug.log&apos;),#日志输出文件 &apos;maxBytes&apos;:1024*1024*5,#文件大小 &apos;backupCount&apos;: 5,#备份份数 &apos;formatter&apos;:&apos;standard&apos;,#使用哪种formatters日志格式 &#125;, &apos;console&apos;:&#123;#输出到控制台 &apos;level&apos;: &apos;DEBUG&apos;, &apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;standard&apos;, &#125;, &#125;, &apos;loggers&apos;: &#123;#logging管理器 &apos;django&apos;: &#123; &apos;handlers&apos;: [&apos;console&apos;], &apos;level&apos;: &apos;DEBUG&apos;, &apos;propagate&apos;: False &#125;, &apos;django.request&apos;: &#123; &apos;handlers&apos;: [&apos;debug&apos;,&apos;mail_admins&apos;], &apos;level&apos;: &apos;ERROR&apos;, &apos;propagate&apos;: True, &#125;, # 对于不在 ALLOWED_HOSTS 中的请求不发送报错邮件 &apos;django.security.DisallowedHost&apos;: &#123; &apos;handlers&apos;: [&apos;null&apos;], &apos;propagate&apos;: False, &#125;, &#125; &#125; 以上的配置文件中，有三个日志处理器。分别是： ‘django.request’：django的request发生error会自动记录，然后使用debug将信息记录到文件，还有mail_admins将信息通过邮件发送给管理员。这里邮件的功能非常棒！并不是一个纯文本信息，而是一个html文件，和我们在浏览器看到的错误页面一模一样！要正常使用邮件功能需要像我一样配置一下上面的邮件发件人信息。我是直接去网易申请了一个邮箱。要格外注意三点： 一定要去邮件服务商开启SMTP服务； 不同的邮件服务商可能有一些特殊的设置，比如网易，会给你一个客户端授权码，这个才是密码，而不是网页的登录密码。 注意服务商有没有对发信频率的限制。 ‘django’：使用console处理器，将信息输出。在开发的时候就可以使用这个处理器（什么？print？ 太low了！） 最后一个处理器见注 释 8）日志模块流程图","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Django","slug":"技术栈/Django","permalink":"https://angeszhu.github.io/categories/技术栈/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://angeszhu.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://angeszhu.github.io/tags/Web框架/"},{"name":"测试开发","slug":"测试开发","permalink":"https://angeszhu.github.io/tags/测试开发/"}]},{"title":"Django安装以及创建项目","slug":"install-django","date":"2019-06-01T02:44:55.000Z","updated":"2019-06-02T14:41:59.593Z","comments":true,"path":"2019/06/01/install-django/","link":"","permalink":"https://angeszhu.github.io/2019/06/01/install-django/","excerpt":"","text":"Django安装以及创建项目Django安装Python版本以及Django版本选择Django2.0以上版本，支持Python3.4以上的版本，而取消对Python2的支持。 而Django 1.11是支持Python2.7的最后版本。 压缩包下载安装下载Django 下载Python的第三方库包地址 下载 Django 压缩包， 解压并和Python安装目录放在同一个根目录， 进入 Django 目录，执行python setup.py install， 然后开始安装，Django将要被安装到Python的Lib下site-packages。 然后是配置环境变量，将这几个目录添加到系统环境变量中: C:\\Python33\\Lib\\site-packages\\django;C:\\Python33\\Scripts。 添加完成后就可以使用Django的django-admin.py命令新建工程了。 Pip命令安装在终端输入以下命令： 1pip install Django 如果想要制定Django版本，那么可以输入，当然版本号可以根据需要来输入: 1pip install Django==2.0.5 检查Django是否安装成功输入以下命令进行检查： 12import djangodjango.__version__ 如果出现如下图一样的内容，那么证明你安装成功了。 Django项目的创建1.命令行创建django项目在终端输入命令:django-admin startproject 项目名称 注意:你在哪个目录输入命令创建，你的项目就会创建到哪里 2.使用编译器创建Django项目选择:File -&gt; New Project 选择django，填写django项目名称， 选择环境运行的sdk以及django配置，是否创建app，app名称等内容 3.Django的目录结构 一个Django项目，可以包含多个项目应用， 这些应用在Django中，又可以称为app。 每一个app代表网站的一个，或多个网页。 创建 app时，可以进入项目目录， 然后用命令： python manage.py startapp app名称 创建 也可以在pycharm创建项目时，就一起创建好，pycharm给我们提供了这样的功能。 4.Django项目的启动1.命令行启动 python manage.py runserver 2.pycharm启动 在图中我们可以看到，右上角的运行附近，有一个选择框。 这里可以选择我们的django项目，点击右侧三角，即可运行django调试服务器。 而另外一个选项，Edit，可以配置我们django项目启动的一些信息，例如:ip、端口号等 如果没有Dj启动，也可以利用Edit添加一个Django启动。 但是添加的时候要跟Django配置的一样。 这里最重要的，就是在设置中，把setting加载进去。 启动后在浏览器输入地址:127.0.0.1:8000 可以打开成功页面，即项目创建成功","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Django","slug":"技术栈/Django","permalink":"https://angeszhu.github.io/categories/技术栈/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://angeszhu.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://angeszhu.github.io/tags/Web框架/"},{"name":"测试开发","slug":"测试开发","permalink":"https://angeszhu.github.io/tags/测试开发/"}]},{"title":"Django介绍","slug":"django-info","date":"2019-06-01T02:09:40.000Z","updated":"2019-06-01T02:37:22.520Z","comments":true,"path":"2019/06/01/django-info/","link":"","permalink":"https://angeszhu.github.io/2019/06/01/django-info/","excerpt":"","text":"什么是Djangodjango(Python Web 框架) Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控 制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS(内容 管理系统)软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。 架构设计Django是一个基于MVC构造的框架。 但是在Django中，控制器接受用户输入的部分由框架自行处理， 所以 Django 里更关注的是模型(Model)、模板(Template)和视图(Views)，称为 MTV模式。 它们各自的职责 如下: 层次 职责 模型(Model)，即数 据存取层 处理与数据相关的所有事务: 如何存取、如何验证有效性、包含哪些行为 以及数据之间的关系等。 模板(Template)，即表 现层 处理与表现相关的决定: 如何在页面或其他类型文档中进行显示。 视图(View)，即业务 逻辑层 存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁。 从以上表述可以看出Django视图不处理用户输入，而仅仅决定要展现哪些数据给用户， 而Django模板仅仅决定如何展现Django视图指定的数据。 或者说, Django将MVC中的视图进一步分解为 Django视图 和 Django模板两个部分， 分别决定 “展现哪些数据” 和 “如何展现”，使得Django的模板可以根据需要随时替 换，而不仅仅限制于内置的模板。 至于MVC控制器部分，由Django框架的URLconf来实现。URLconf机制是使用正则表达式匹配URL， 然后调 用合适的Python函数。URLconf对于URL的规则没有任何限制，你完全可以设计成任意的URL风格， 不管是 传统的，RESTful的，或者是另类的。 框架把控制层给封装了，无非与数据交互这层都是数据库表的读,写,删 除,更新的操作。 在写程序的时候，只要调用相应的方法就行了，感觉很方便。 程序员把控制层东西交给 Django自动完成了。 只需要编写非常少的代码完成很多的事情。 所以，它比MVC框架考虑的问题要深一 步，因为我们程序员大都在写控制层的程序。 现在这个工作交给了框架，仅需写很少的调用代码，大大提高 了工作效率。 Django的主要目的是简便、快速的开发数据库驱动的网站。 它强调代码复用，多个组件可以很方便的以“插 件”形式服务于整个框架， Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。 这使得Django具有很强的可扩展性。 它还强调快速开发和DRY(Do Not Repeat Yourself)原则。 Django基于MVC的设计十分优美: 对象关系映射 (ORM,object-relational mapping): 以Python类形式定义你的数据模型，ORM将模型与 关系数据库连接起来，你将得到一个非常容易使用的数据库API，同时你也可以在Django中使用原始的 SQL语句。 URL 分派: 使用正则表达式匹配URL，你可以设计任意的URL，没有框架的特定限定。像你喜欢的一样 灵活。 模版系统: 使用Django强大而可扩展的模板语言，可以分隔设计、内容和Python代码。并且具有可继 承性。 表单处理: 你可以方便的生成各种表单模型，实现表单的有效性检验。可以方便的从你定义的模型实例 生成相应的表单。 Cache系统: 可以挂在内存缓冲或其它的框架实现超级缓冲 – 实现你所需要的粒度。 会话(session)，用户登录与权限检查，快速开发用户会话功能。 国际化: 内置国际化系统，方便开发出多种语言的网站。 自动化的管理界面: 不需要你花大量的工作来创建人员管理和更新内容。Django自带一个ADMIN site, 类似于内容管理系统 工作机制 1.用manage .py runserver 启动Django服务器时就载入了在同一目录下的settings .py。该文件包含了项目 中的配置信息，如前面讲的URLConf等，其中最重要的配置就是ROOT_URLCONF，它告诉Django哪个 Python模块应该用作本站的URLConf，默认的是urls .py2.当访问url的时候，Django会根据ROOT_URLCONF的设置来装载URLConf。 3.然后按顺序逐个匹配URLConf里的URLpatterns。如果找到则会调用相关联的视图函数，并把HttpRequest对象作为第一个参数(通常是request) 4.最后该view函数负责返回一个HttpResponse对象 附录(点击可进入) The Django Book Django官方网站 Django官方文档","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Django","slug":"技术栈/Django","permalink":"https://angeszhu.github.io/categories/技术栈/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://angeszhu.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://angeszhu.github.io/tags/Web框架/"},{"name":"测试开发","slug":"测试开发","permalink":"https://angeszhu.github.io/tags/测试开发/"}]},{"title":"Python环境的安装","slug":"install-python","date":"2019-05-31T13:20:58.000Z","updated":"2019-05-31T14:28:44.392Z","comments":true,"path":"2019/05/31/install-python/","link":"","permalink":"https://angeszhu.github.io/2019/05/31/install-python/","excerpt":"Python安装以及Pycharm安装本篇简单介绍一下Python的开发环境的安装","text":"Python安装以及Pycharm安装本篇简单介绍一下Python的开发环境的安装 版本选择 目前，根据数据显示，使用Python2.xd 开发者站63.7%，而使用Python3.x的用户站36.3%，由此可见使用使用Python2.x的用户还是占多数。2014年，Python的创始人宣布将Python2.7支持时间延长到2020年，那么初学者应该选择什么版本呢？目前建议初学者选择Python3.x版本1、目前，使用Python3.x是大势所趋2、Python3.x在Python2.x的基础上做了功能升级3、Python3.x和Python2.x思想基本是共通的当然选择Python3.x也会有缺点，那就是很多扩展库的发行总是滞后于Python的发行版本，甚至目前还有很多库不支持Python3.x。因此，在选择Python时候，一定要先考虑清楚自己的学习目的，例如，打算做哪方面的开发、需要用到哪些扩展库，以及扩展库支持的最高Python版本等。明确这些问题后再做出适合自己的选择。 我们这里选择的介绍安装的版本是Python 3.7.2 Python安装下载安装包首先我们需要去官网选择我们想要下载的Python版本。 Python官网下载地址点击跳转 可以在页面中选择您想要下载安装的python版本 我们选择的版本是Python3.7.2 选择版本后，进入下一个页面，页面拖到最下方，我们可以看到一个表格。 我们可以在这个表格中，根据您的操作系统等，来选择您想要下载安装的Python安装包。 我们本教程选择的版本是: 点击后，即可下载Python安装包。 安装Python（Windows系统）双击我们下载好的安装包，打开安装界面(如下图)。 红圈块的地方，给大家详细说明一下。 1.默认安装这里的默认安装，包含了Python的安装目录，我们可以看到红圈中的路径，那个路径，就是我们Python安装完的路径。 2.自定义安装 在下面的步骤中，我们可以选择安装的很多内容，这里我们需要注意的就是这个安装目录。 由于Window启动和运行的一些问题，我们并不推荐安装至C盘，所以大家尽量换一个盘来装。 我们这里换到了D盘。 3.添加Python至环境变量环境变量这里，大家一定要勾选，因为可以节省我们很多事情。防止因为环境变量配置错误而出现异常。 点击安装后，Python就已经开始安装了。 当出现如上图时，证明我们的Python就已经安装成功了。 我们现在就可以来检查一下Python是否安装成功了。 win+R 输入cmd 打开我们的dos界面，输入python 当出现如上图时，证明我们的python正确安装了。 输入pip，可以查看我们的pip是否可以正常使用。 安装Python（Mac系统）因为系统中有一些内容是基于Python来运行，Mac系统是自带Python环境的。 但是这个Python环境版本为2.x的Python，想要直接使用Python2.x版本的Python，则不需要安装。 Mac系统中的Python安装就相对简单很多，只需要我们下载好安装包，安装就好。 他有很多内容并不需要我们来勾选。 多Python版本兼容windows系统在一些情况下，我们的电脑需要安装两个版本的Python，那么就会有一个兼容的问题。 官方给我们提供了一个小工具:py.exe py.exe存在于python3.X以上的版本，存在目录:C:\\Windows py.exe的使用: Python启动: 12python2.X: py -2 python3.X: py -3 Pip的启动: Pip的使用与正常pip使用一致，只是把命令pip替换成带有 目标版本的命令 12python2.X: py -2 –m pip python3.X: py -3 –m pip Python启动声明python版本: 12python2.X: #!python2 python3.X: #!python3 mac系统在mac中使用python，在命令上加上3即可。 Windows中的py.exe并不存在。 相较windows来说，要简单很多，具体使用如下图： Pycharm安装下载以及安装首先我们需要去官网选择我们想要下载的Python版本。 社区版：功能简单，可以满足日常练习以及写脚本的需求，但在项目级开发时，略显不足。 专业版：功能全面，可以满足所有的Python开发使用。 社区版免费，专业版需要激活或者购买。 Pycharm官网下载地址点击跳转 Windows下安装Pycharm，需注意安装路径不要有中文。 Mac下直接把Pycharm安装到应用程序即可。 激活 服务器激活 在license server中输入地址:http://xidea.online 地址不唯一，随意百度有很多可以使用的。 修改时间方式(新版本不可用) Pycharm注册界面不动 调整电脑系统时间2038年(时间随意) 注册界面选择申请30天试用 退出pycharm 电脑时间调整回正常时间 淘宝购买全家桶账号激活 缺点:激活一次管一年，到期后要找客服免费续期 网上下载jar包，修改配置激活 但是要注意jar包与Pycharm版本的对应关系，并不是所有的版本都可以用一个jar包激活。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"https://angeszhu.github.io/categories/技术栈/"},{"name":"Python","slug":"技术栈/Python","permalink":"https://angeszhu.github.io/categories/技术栈/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://angeszhu.github.io/tags/Python/"},{"name":"环境","slug":"环境","permalink":"https://angeszhu.github.io/tags/环境/"}]},{"title":"技术栈（简单整理）","slug":"Knowledge-system","date":"2019-05-31T08:25:28.000Z","updated":"2019-05-31T08:32:17.785Z","comments":true,"path":"2019/05/31/Knowledge-system/","link":"","permalink":"https://angeszhu.github.io/2019/05/31/Knowledge-system/","excerpt":"","text":"","categories":[{"name":"日常需要","slug":"日常需要","permalink":"https://angeszhu.github.io/categories/日常需要/"},{"name":"寻找目标","slug":"日常需要/寻找目标","permalink":"https://angeszhu.github.io/categories/日常需要/寻找目标/"}],"tags":[{"name":"知识体系 学习方向 职业规划","slug":"知识体系-学习方向-职业规划","permalink":"https://angeszhu.github.io/tags/知识体系-学习方向-职业规划/"}]},{"title":"Markdown使用手册（持续更新）","slug":"Markdown-text","date":"2019-05-29T07:56:53.000Z","updated":"2019-05-31T08:18:20.080Z","comments":true,"path":"2019/05/29/Markdown-text/","link":"","permalink":"https://angeszhu.github.io/2019/05/29/Markdown-text/","excerpt":"Markdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。","text":"Markdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 它的优缺点优点： 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 Markdown语法 一、标题在想要设置为标题的文字前面加符号#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字。示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 二、字体 加粗 要加粗的文字左右分别用两个’*’号包起来 斜体 要倾斜的文字左右分别用一个’*’号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个’*’号包起来 删除线 要加删除线的文字左右分别用两个’~~’号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用示例： 1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。示例： 1234-------******** 效果如下： 五、图片语法：![图片alt](图片地址 ‘’图片title’’) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![](https://www.baidu.com/link?url=Oshs7TTIS7ATkTi_mTNlFyP2mBI3Jpg9oRrO2kY9c7HsH1fxPGuV36DcNatRqI00WOvZVk9jqhCJugunwZd0szzwyJSL48TZqxexmJx_FxXn5vHaZ4R1XIFzXym_uWsh54i7241XpLSXkWYV71RZR-RRLeSiq-fOcSd-NPaY2jYqyIDN-tH_lvb_zX83bEJ2ciaV5f_HAF8xoEB3O6eWWvvB_iNnlYEEW4EBaaX73tOvcm-c4Iu_6A4LCncOSdADHdDOAYZbyP6dPTZaGbKjGdmZkxeTzN3Ln8EagEz7elDJCPlAlT3Xx3fr9v2TOVh9T_XonNm8XJ_jTtimSGNvh72wKSimrhns9kM-bio8Y6G_sPOcE91lAJfUyqmWOFQ4HNDo0U5uF-LXzL6qazjHZdAL4422LCf3OoQW8FywGDHmrL7pIoXKn3wGcIEjgf3IV-ZrfIDmq2UsfB7oxpENGMtQiGtjTqdJ5PFNxCxFMe-HykBsCjkl33t2raHgYco_QOId237Qzw7KTpmpDu5cm-uIYTrm9j0jjnjiwcJJyT-kk0xcySjOwk4FT2xBxo0I8h3rwhYUJkxXtDi1YHUyI5rvFo9UBxVnqLBV8mx0CcjRnxeDWWxpOKrfJSGz9aPERRR0ApPP1A3PlL8zKMLmE_&amp;timg=&amp;click_t=1559285904085&amp;s_info=1425_789&amp;wd=&amp;eqid=adaa6738000d4b05000000045cf0d08c &quot;小猫咪&quot;) 由于Hexo对网络图片不太友好，大家就自己试效果吧。 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度注：Markdown本身语法不支持链接在新页面中打开。 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 123- 列表内容+ 列表内容* 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点1.列表内容2.列表内容3.列表内容 注意：序号跟内容之间要有空格 效果如下：1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 示例： 12345678910111213141516171819* 一级无序列表内容 * 二级无序列表内容 * 二级无序列表内容 * 二级无序列表内容* 一级无序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容1.一级有序列表内容 * 二级无序列表内容 * 二级无序列表内容 * 二级无序列表内容2.一级有序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 效果如下： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 1.一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2.一级有序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例：单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下：单行代码create database hero;代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十、流程图 一个纯文本的语法怎么画图？ 1将流程图代码包含在```folw和```之间即可 流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素) 创建流程（元素）：tag=&gt;type: content:&gt;url tag 是流程图中的标签，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。 type 用来确定标签的类型，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型 标签有6种类型：start end operation subroutine condition inputoutput content 是流程图文本框中的描述内容，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格 url是一个连接，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面 指向流程(连接元素)：标识（类别）-&gt;下一个标识 使用 -&gt; 来连接两个元素 对于condition类型，有yes和no两个分支，如示例中的cond(yes)和cond(no) 每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。 流程图元素 开始st=&gt;start: 开始 操作op1=&gt;operation: 操作、执行说明 条件cond=&gt;condition: 确认？ 子程序sub1=&gt;subroutine: 子程序操作说明 用户输入或输出io1=&gt;inputoutput: 输入密码 结束e=&gt;end: 结束 十一 整一个To Do List12- [x] 学习python基础 【减号+[+空格或x+]+空格】- [ ] 学习python网络编程 学习python基础 【减号+[+空格或x+]+空格】 学习python网络编程 参考资料：https://www.jianshu.com/p/191d1e21f7edst=>start: 开始 e=>end: 登录 io1=>inputoutput: 输入用户名密码 sub1=>subroutine: 数据库查询子类 cond=>condition: 是否有此用户 cond2=>condition: 密码是否正确 op=>operation: 读入用户信息 st->io1->sub1->cond cond(yes,right)->cond2 cond(no)->io1(right) cond2(yes,right)->op->e cond2(no)->io1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"日常需要","slug":"日常需要","permalink":"https://angeszhu.github.io/categories/日常需要/"},{"name":"文档编写","slug":"日常需要/文档编写","permalink":"https://angeszhu.github.io/categories/日常需要/文档编写/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://angeszhu.github.io/tags/Markdown/"},{"name":"文档编写","slug":"文档编写","permalink":"https://angeszhu.github.io/tags/文档编写/"}]}]}